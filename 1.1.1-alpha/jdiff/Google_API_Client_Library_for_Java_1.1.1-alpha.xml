<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Sep 14 09:45:40 EDT 2010 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Google API Client Library for Java 1.1.1-alpha"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/yanivi/programs/jdiff-1.1.1/jdiff.jar:/home/yanivi/programs/jdiff-1.1.1/xerces.jar -d /home/yanivi/eclipse/workspaces/gdata/javadoc/1.1.1-alpha/jdiff -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/java/xmlParserAPIs.jar:/usr/share/java/xercesImpl.jar:/usr/share/ant/lib/ant-javamail.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-jsch.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-apache-bcel.jar:/usr/share/ant/lib/ant-apache-regexp.jar:/usr/share/ant/lib/ant-apache-resolver.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-commons-net.jar:/usr/share/ant/lib/ant-jdepend.jar:/usr/share/ant/lib/ant-apache-bsf.jar:/usr/share/ant/lib/ant-apache-oro.jar:/usr/share/ant/lib/ant-apache-log4j.jar:/usr/share/ant/lib/ant-antlr.jar:/usr/share/ant/lib/ant-trax.jar:/usr/share/ant/lib/ant-commons-logging.jar:/usr/local/buildtools/java/jdk6-google-v2/lib/tools.jar -sourcepath /home/yanivi/eclipse/workspaces/gdata/google-api-java-client/google-api-client/src -apiname Google API Client Library for Java 1.1.1-alpha -baseURI http://www.w3.org -apidir /home/yanivi/eclipse/workspaces/gdata/javadoc/1.1.1-alpha/jdiff -source 1.5 -->
<package name="com.google.api.client.android.xml">
  <!-- start class com.google.api.client.android.xml.AndroidXmlParserFactory -->
  <class name="AndroidXmlParserFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.xml.XmlParserFactory"/>
    <constructor name="AndroidXmlParserFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[XML parser factory for Android.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.android.xml.AndroidXmlParserFactory -->
  <doc>
  <![CDATA[Android XML utilities.

<p>This package depends on the {@link com.google.api.client.http}, and
{@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.apache">
  <!-- start class com.google.api.client.apache.ApacheHttpTransport -->
  <class name="ApacheHttpTransport" extends="com.google.api.client.http.LowLevelHttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.apache.ApacheHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
    </method>
    <field name="httpClient" type="HttpClient"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Apache HTTP client.

 @since 1.1]]>
      </doc>
    </field>
    <field name="INSTANCE" type="com.google.api.client.apache.ApacheHttpTransport"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Singleton instance of this transport.
 <p>
 Sample usage:

 <pre><code>HttpTransport.setLowLevelHttpTransport(ApacheHttpTransport.INSTANCE);</code></pre>
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP low-level transport based on the Apache HTTP Client library.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.apache.ApacheHttpTransport -->
  <doc>
  <![CDATA[HTTP Transport library for Google API's based on Apache HTTP Client version 4.

<p>This package depends on the {@link com.google.api.client.http} and {@code
org.apache.http.*} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.auth">
  <!-- start class com.google.api.client.auth.HmacSha -->
  <class name="HmacSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given secret key.
 
 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "HMAC-SHA1"} signing method.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.HmacSha -->
  <!-- start class com.google.api.client.auth.RsaSha -->
  <class name="RsaSha" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPrivateKeyFromKeystore" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyStream" type="java.io.InputStream"/>
      <param name="storePass" type="java.lang.String"/>
      <param name="alias" type="java.lang.String"/>
      <param name="keyPass" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Retrieves the private key from the specified key store.
 
 @param keyStream input stream to the key store file
 @param storePass password protecting the key store file
 @param alias alias under which the private key is stored
 @param keyPass password protecting the private key
 @return the private key from the specified key store
 @throws GeneralSecurityException if the key store cannot be loaded
 @throws IOException if the file cannot be accessed]]>
      </doc>
    </method>
    <method name="getPrivateKeyFromPk8" return="java.security.PrivateKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Reads a {@code PKCS#8} format private key from a given file.
 
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="sign" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateKey" type="java.security.PrivateKey"/>
      <param name="data" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Signs the given data using the given private key.
 
 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for {@code "RSA-SHA1"} signing method.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.RsaSha -->
  <doc>
  <![CDATA[Utilities for authentication and authorization.

<p>This package depends on the {@link com.google.api.client.util} package.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.auth.oauth">
  <!-- start class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <class name="AbstractOAuthGetToken" extends="com.google.api.client.http.GenericUrl"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractOAuthGetToken" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="execute" return="com.google.api.client.auth.oauth.OAuthCredentialsResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the HTTP request for a temporary or long-lived token.
 
 @return OAuth credentials response object
 @throws HttpResponseException for an HTTP error code
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of the OAuth authentication provider. Subclasses may
 override by calling this super implementation and then adding OAuth
 parameters.]]>
      </doc>
    </method>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a
 username).]]>
      </doc>
    </field>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="usePost" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code true} for POST request or the default {@code false} for GET request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary or long-lived token from an
 authorization server.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.AbstractOAuthGetToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <class name="OAuthAuthorizeTemporaryTokenUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthAuthorizeTemporaryTokenUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedUserAuthorizationUrl encoded user authorization URL]]>
      </doc>
    </constructor>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials token obtained from temporary credentials request
 in the "oauth_token" parameter. It is found in the
 {@link OAuthCredentialsResponse#token} returned by
 {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a URL builder for an authorization web page to allow the end user to
 authorize the temporary token.
 <p>
 The {@link #temporaryToken} should be set from the
 {@link OAuthCredentialsResponse#token} returned by
 {@link OAuthGetTemporaryToken#execute()}. Use {@link #build()} to build the
 authorization URL. If a {@link OAuthGetTemporaryToken#callback} was
 specified, after the end user grants the authorization, the authorization
 server will redirect to that callback URL. To parse the response, use
 {@link OAuthCallbackUrl}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <class name="OAuthCallbackUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCallbackUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The temporary credentials identifier received from the client.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic URL that parses the callback URL after a temporary token has been
 authorized by the end user.
 <p>
 The {@link #verifier} is required in order to exchange the authorized
 temporary token for a long-lived access token in
 {@link OAuthGetAccessToken#verifier}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCallbackUrl -->
  <!-- start class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <class name="OAuthCredentialsResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthCredentialsResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials token.]]>
      </doc>
    </field>
    <field name="tokenSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Credentials shared-secret for use with {@code "HMAC-SHA1"} signature
 algorithm. Used for {@link OAuthHmacSigner#tokenSharedSecret}.]]>
      </doc>
    </field>
    <field name="callbackConfirmed" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "true"} for temporary credentials request or {@code null} for a
 token credentials request. The parameter is used to differentiate from
 previous versions of the protocol.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Data to parse a success response to a request for temporary or token
 credentials.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthCredentialsResponse -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <class name="OAuthGetAccessToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetAccessToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="temporaryToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required temporary token. It is retrieved from the
 {@link OAuthCredentialsResponse#token} returned from
 {@link OAuthGetTemporaryToken#execute()}.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required verifier code received from the server when the temporary token
 was authorized. It is retrieved from {@link OAuthCallbackUrl#verifier}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request to exchange the temporary credentials token
 (or "request token") for a long-lived credentials token (or "access token")
 from an authorization server.
 <p>
 Use {@link #execute()} to execute the request. The long-lived access token
 acquired with this request is found in {@link OAuthCredentialsResponse#token}
 . This token must be stored. It may then be used to authorize HTTP requests
 to protected resources by setting the {@link OAuthParameters#token}, and
 invoking
 {@link OAuthParameters#signRequestsUsingAuthorizationHeader(HttpTransport)}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetAccessToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <class name="OAuthGetTemporaryToken" extends="com.google.api.client.auth.oauth.AbstractOAuthGetToken"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthGetTemporaryToken" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param authorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional absolute URI back to which the server will redirect the resource
 owner when the Resource Owner Authorization step is completed or {@code
 null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic OAuth 1.0a URL to request a temporary credentials token (or
 "request token") from an authorization server.
 <p>
 Use {@link #execute()} to execute the request. The temporary token acquired
 with this request is found in {@link OAuthCredentialsResponse#token}. This
 temporary token is used in
 {@link OAuthAuthorizeTemporaryTokenUrl#temporaryToken} to direct the end user
 to an authorization page to allow the end user to authorize the temporary
 token.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthGetTemporaryToken -->
  <!-- start class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <class name="OAuthHmacSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthHmacSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="clientSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Client-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <field name="tokenSharedSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token-shared secret or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "HMAC-SHA1"} signature method.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthHmacSigner -->
  <!-- start class com.google.api.client.auth.oauth.OAuthParameters -->
  <class name="OAuthParameters" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OAuthParameters"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="computeNonce"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a nonce based on the hex string of a random non-negative long,
 setting the value of the {@link #nonce} field.]]>
      </doc>
    </method>
    <method name="computeTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a timestamp based on the current system time, setting the value of
 the {@link #timestamp} field.]]>
      </doc>
    </method>
    <method name="computeSignature"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requestMethod" type="java.lang.String"/>
      <param name="requestUrl" type="com.google.api.client.http.GenericUrl"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Computes a new signature based on the fields and the given request method
 and URL, setting the values of the {@link #signature} and
 {@link #signatureMethod} fields.
 
 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <method name="getAuthorizationHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the {@code Authorization} header value to use with the OAuth
 parameter values found in the fields.]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of the given value using OAuth escaping rules.]]>
      </doc>
    </method>
    <method name="signRequestsUsingAuthorizationHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Performs OAuth HTTP request signing via the {@code Authorization} header as
 the final HTTP request execute intercepter for the given HTTP transport.]]>
      </doc>
    </method>
    <field name="signer" type="com.google.api.client.auth.oauth.OAuthSigner"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required OAuth signature algorithm.]]>
      </doc>
    </field>
    <field name="callback" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Absolute URI back to which the server will redirect the resource owner when
 the Resource Owner Authorization step is completed.]]>
      </doc>
    </field>
    <field name="consumerKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required identifier portion of the client credentials (equivalent to a
 username).]]>
      </doc>
    </field>
    <field name="nonce" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required nonce value. Should be computed using {@link #computeNonce()}.]]>
      </doc>
    </field>
    <field name="realm" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Realm.]]>
      </doc>
    </field>
    <field name="signature" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Signature. Required but normally computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="signatureMethod" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Name of the signature method used by the client to sign the request.
 Required, but normally computed using {@link #computeSignature}.]]>
      </doc>
    </field>
    <field name="timestamp" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required timestamp value. Should be computed using
 {@link #computeTimestamp()}.]]>
      </doc>
    </field>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token value used to associate the request with the resource owner or
 {@code null} if the request is not associated with a resource owner.]]>
      </doc>
    </field>
    <field name="verifier" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The verification code received from the server.]]>
      </doc>
    </field>
    <field name="version" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must either be "1.0" or {@code null} to skip. Provides the version of the
 authentication process as defined in this specification.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 1.0a parameter manager.
 <p>
 The only required non-computed fields are {@link #signer} and
 {@link #consumerKey}. Use {@link #token} to specify token or temporary
 credentials.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthParameters -->
  <!-- start class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <class name="OAuthRsaSigner" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.auth.oauth.OAuthSigner"/>
    <constructor name="OAuthRsaSigner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
    </method>
    <field name="privateKey" type="java.security.PrivateKey"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Private key.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth {@code "RSA-SHA1"} signature method.
 <p>
 The private key may be retrieved using the utilities in {@link RsaSha}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth.OAuthRsaSigner -->
  <!-- start interface com.google.api.client.auth.oauth.OAuthSigner -->
  <interface name="OAuthSigner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSignatureMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the signature method.]]>
      </doc>
    </method>
    <method name="computeSignature" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="signatureBaseString" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Returns the signature computed from the given signature base string.
 
 @throws GeneralSecurityException general security exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[OAuth signature method.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.auth.oauth.OAuthSigner -->
  <doc>
  <![CDATA[OAuth 1.0 authorization as specified in
<a href="http://tools.ietf.org/html/rfc5849">RFC 5849: The OAuth 1.0
Protocol</a>
(see detailed package specification).


<p>There are a few features not supported by this implementation:
<ul>
  <li>{@code PLAINTEXT} signature algorithm</li>
  <li>{@code "application/x-www-form-urlencoded"} HTTP request body</li>
  <li>{@code "oauth_*"} parameters specified in the HTTP request URL
  (instead assumes they are specified in the {@code Authorization} header)</li>
</ul>

<p>Before using this library, you may need to set up your application as
follows:</p>
<ol>
  <li>For web applications, you may need to first register your application
  with the authorization server. It may provide two pieces of information you
  need:
  <ul>
    <li>OAuth Consumer Key: use this as the {@code consumerKey} on every
    OAuth request, for example in {@link
    com.google.api.client.auth.oauth.AbstractOAuthGetToken#consumerKey}.</li>
    <li>OAuth Consumer Secret: use this as the {@link
    com.google.api.client.auth.oauth.OAuthHmacSigner#clientSharedSecret} when
    using the {@code "HMAC-SHA1"} signature method.</li>
  </ul>
  </li>
  <li>For an installed application, an unregistered web application, or a
  web application running on localhost, you must use the {@code "HMAC-SHA1"}
  signature method. The documentation for the authorization server will need to
  provide you with the {@code consumerKey} and {@code clientSharedSecret} to
  use.</li>
  <li>For the {@code "HMAC-SHA1"} signature method, use {@link
  com.google.api.client.auth.oauth.OAuthHmacSigner}.</li>
  <li>For the {@code "RSA-SHA1"} signature method, use {@link
  com.google.api.client.auth.oauth.OAuthRsaSigner}.</li>
</ol>
<p>After the set up has been completed, the typical application flow is:</p>
<ol>
  <li>Request a temporary credentials token from the Authorization server
  using {@link com.google.api.client.auth.oauth.OAuthGetTemporaryToken}. A
  callback URL should be specified for web applications, but does not need to be
  specified for installed applications.</li>
  <li>Direct the end user to an authorization web page to allow the end
  user to authorize the temporary token using using {@link
  com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl}.</li>
  <li>After the user has granted the authorization:
  <ul>
    <li>For web applications, the user's browser will be redirected to the
    callback URL which may be parsed using {@link
    com.google.api.client.auth.oauth.OAuthCallbackUrl}.</li>
    <li>For installed applications, see the authorization server's
    documentation for figuring out the verification code.</li>
  </ul>
  </li>
  <li>Request to exchange the temporary token for a long-lived access token
  from the Authorization server using {@link
  com.google.api.client.auth.oauth.OAuthGetAccessToken}. This access token must
  be stored.</li>
  <li>Use the stored access token to authorize HTTP requests to protected
  resources by setting the {@link
  com.google.api.client.auth.oauth.OAuthParameters#token} and invoking
  {@link
  com.google.api.client.auth.oauth.OAuthParameters#signRequestsUsingAuthorizationHeader}.</li>
</ol>

<p>This package depends on the {@link com.google.api.client.auth}, {@link
com.google.api.client.escape}, {@link com.google.api.client.http}, and {@link
com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.auth.oauth2">
  <!-- start class com.google.api.client.auth.oauth2.AbstractAuthorizationRequestUrl -->
  <class name="AbstractAuthorizationRequestUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determines how the authorization server delivers the authorization response
 back to the client.]]>
      </doc>
    </field>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client identifier.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[REQUIRED unless a redirection URI has been established between the client
 and authorization server via other means. An absolute URI to which the
 authorization server will redirect the user-agent to when the end-user
 authorization step is completed. The authorization server SHOULD require
 the client to pre-register their redirection URI. Authorization servers MAY
 restrict the redirection URI to not include a query component as defined by
 [RFC3986] section 3.]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) An opaque value used by the client to maintain state between the
 request and callback. The authorization server includes this value when
 redirecting the user-agent back to the client.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of
 space-delimited strings. The value of the "scope" parameter is defined by
 the authorization server. If the value contains multiple space-delimited
 strings, their order does not matter, and each string adds an additional
 access range to the requested scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 URL builder for an authorization web page to allow the end user to
 authorize the application to access their protected resources as specified in
 <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-4.1.1"
 >User-Agent Flow</a>.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AbstractAuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.AbstractAuthorizationResponse -->
  <class name="AbstractAuthorizationResponse" extends="com.google.api.client.util.GenericData"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user denies authorization) MUST be set to
 "user_denied".]]>
      </doc>
    </field>
    <field name="state" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[REQUIRED if the "state" parameter was present in the client authorization
 request. Set to the exact value received from the client.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 parser for the redirect URL after end user grants or denies
 authorization as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-4.1.1.1"
 >Authorization Server Response</a>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AbstractAuthorizationResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AccessProtectedResource -->
  <class name="AccessProtectedResource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="usingAuthorizationHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Authorization"} header using the given access token for
 every executed HTTP request for the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2
 access token will be removed.
 
 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <method name="usingQueryParameter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "oauth_token"} URI query parameter using the given access
 token for every executed HTTP request for the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2
 access token will be removed.
 
 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <method name="usingFormEncodedBody"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "oauth_token"} parameter in the form-encoded HTTP body
 using the given access token for every executed HTTP request for the given
 HTTP transport.
 <p>
 Any existing HTTP request execute intercepters for setting the OAuth 2
 access token will be removed. Requirements:
 <ul>
 <li>The HTTP method must be "POST", "PUT", or "DELETE".</li>
 <li>The HTTP content must be {@code null} or {@link UrlEncodedContent}.</li>
 <li>The {@link UrlEncodedContent#data} must be {@code null} or
 {@link GenericData}.</li>
 </ul>
 
 @param transport HTTP transport
 @param accessToken access token]]>
      </doc>
    </method>
    <doc>
    <![CDATA[OAuth 2.0 methods for specifying the access token parameter as specified in
 <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-6">
 Accessing a Protected Resource</a>.
 
 @author Yaniv Inbar
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessProtectedResource -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenErrorResponse -->
  <class name="AccessTokenErrorResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenErrorResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The error code.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 access token error response as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.6" >Error
 Response</a>.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenErrorResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenRequest -->
  <class name="AccessTokenRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="execute" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes request for an access token, and returns the HTTP response.
 
 @return HTTP response, which can then be parsed using
         {@link HttpResponse#parseAs(Class)} with
         {@link AccessTokenResponse}
 @throws HttpResponseException for an HTTP error response, which can then be
         parsed using {@link HttpResponse#parseAs(Class)} on
         {@link HttpResponseException#response} using
         {@link AccessTokenErrorResponse}
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="clientId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The client identifier.]]>
      </doc>
    </field>
    <field name="clientSecret" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the client identifier has a matching secret) The client
 secret.]]>
      </doc>
    </field>
    <field name="encodedAuthorizationServerUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Encoded authorization server URL.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request for an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5">Obtaining
 an Access Token</a>.
 <p>
 This class should be used directly only for the Client Credentials flow
 specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-2.4">Client
 Credentials Flow</a>.
 <p>
 The {@link #clientId} and {@link #clientSecret} fields are required. Call
 {@link #execute()} to execute the request.
 <p>
 Sample usage for Client Credentials flow:
 
 <pre>
 <code>static void requestAccessToken() throws IOException {
   try {
     AccessTokenRequest request = new AccessTokenRequest();
     request.clientId = CLIENT_ID;
     request.clientSecret = CLIENT_SECRET;
     AccessTokenResponse response =
         request.execute().parseAs(AccessTokenResponse.class);
     System.out.println("Access token: " + response.accessToken);
   } catch (HttpResponseException e) {
     AccessTokenErrorResponse response =
         e.response.parseAs(AccessTokenErrorResponse.class);
     System.out.println("Error: " + response.error);
   }
 }</code>
 </pre>
 
 Other flows follow the same general approach, but instantiating a different
 class customized for that flow with additional custom parameters.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.AccessTokenResponse -->
  <class name="AccessTokenResponse" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessTokenResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The access token issued by the authorization server.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime.]]>
      </doc>
    </field>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The refresh token used to obtain new access tokens using the
 same end-user access grant.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access token as a list of space-delimited
 strings. The value of the "scope" parameter is defined by the authorization
 server. If the value contains multiple space-delimited strings, their order
 does not matter, and each string adds an additional access range to the
 requested scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 access token success response content as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.5"
 >Access Token Response</a>.
 <p>
 Use {@link AccessProtectedResource} to authorize executed HTTP requests based
 on the {@link #accessToken}, for example {@code
 AccessProtectedResource.usingAuthorizationHeader(transport,
 response.accessToken)}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AccessTokenResponse -->
  <!-- start class com.google.api.client.auth.oauth2.AssertionAccessTokenRequest -->
  <class name="AssertionAccessTokenRequest" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AssertionAccessTokenRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <field name="assertionType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The format of the assertion as defined by the authorization
 server. The value MUST be an absolute URI.]]>
      </doc>
    </field>
    <field name="assertion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The assertion.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of
 space-delimited strings. The value of the "scope" parameter is defined by
 the authorization server. If the value contains multiple space-delimited
 strings, their order does not matter, and each string adds an additional
 access range to the requested scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Assertion Flow: request an access token based on as assertion as
 specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.3"
 >Assertion</a>.
 <p>
 The {@link #clientId}, {@link #clientSecret}, {@link #assertionType}, and
 {@link #assertion} fields are required. Call {@link #execute()} to execute
 the request.
 <p>
 Sample usage:
 
 <pre>
 <code>static void requestAccessToken(String assertion) throws IOException {
   try {
     AssertionAccessTokenRequest request
         = new AssertionAccessTokenRequest();
     request.clientId = CLIENT_ID;
     request.clientSecret = CLIENT_SECRET;
     request.assertionType = ASSERTION_TYPE;
     request.assertion = assertion;
     AccessTokenResponse response =
         request.execute().parseAs(AccessTokenResponse.class);
     System.out.println("Access token: " + response.accessToken);
   } catch (HttpResponseException e) {
     AccessTokenErrorResponse response =
         e.response.parseAs(AccessTokenErrorResponse.class);
     System.out.println("Error: " + response.error);
   }
 }</code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.AssertionAccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.RefreshAccessTokenRequest -->
  <class name="RefreshAccessTokenRequest" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RefreshAccessTokenRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The refresh token associated with the access token to be
 refreshed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 request to refresh an access token as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.4"
 >Refreshing an Access Token</a>.
 <p>
 The {@link #clientId}, {@link #clientSecret}, and {@link #refreshToken}
 fields are required. Call {@link #execute()} to execute the request.
 <p>
 Sample usage:
 
 <pre>
 <code>static void requestAccessToken(String refreshToken) throws IOException {
   try {
     RefreshAccessTokenRequest request = new RefreshAccessTokenRequest();
     request.clientId = CLIENT_ID;
     request.clientSecret = CLIENT_SECRET;
     request.refreshToken = refreshToken;
     AccessTokenResponse response =
         request.execute().parseAs(AccessTokenResponse.class);
     System.out.println("Access token: " + response.accessToken);
   } catch (HttpResponseException e) {
     AccessTokenErrorResponse response =
         e.response.parseAs(AccessTokenErrorResponse.class);
     System.out.println("Error: " + response.error);
   }
 }</code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.RefreshAccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.ResourceOwnerCredentialsAccessTokenRequest -->
  <class name="ResourceOwnerCredentialsAccessTokenRequest" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ResourceOwnerCredentialsAccessTokenRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <field name="username" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The end-user's username.]]>
      </doc>
    </field>
    <field name="password" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The end-user's password.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The scope of the access request expressed as a list of
 space-delimited strings. The value of the "scope" parameter is defined by
 the authorization server. If the value contains multiple space-delimited
 strings, their order does not matter, and each string adds an additional
 access range to the requested scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Username and Password Flow: request an access token based on
 resource owner credentials used in the as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.2"
 >Resource Owner Credentials</a>.
 <p>
 The {@link #clientId}, {@link #clientSecret}, {@link #username}, and
 {@link #password} fields are required. Call {@link #execute()} to execute the
 request.
 <p>
 Sample usage:
 
 <pre>
 <code>static void requestAccessToken(String username, String password)
     throws IOException {
   try {
     ResourceOwnerCredentialsAccessTokenRequest request
         = new ResourceOwnerCredentialsAccessTokenRequest();
     request.clientId = CLIENT_ID;
     request.clientSecret = CLIENT_SECRET;
     request.username = username;
     request.password = password;
     AccessTokenResponse response =
         request.execute().parseAs(AccessTokenResponse.class);
     System.out.println("Access token: " + response.accessToken);
   } catch (HttpResponseException e) {
     AccessTokenErrorResponse response =
         e.response.parseAs(AccessTokenErrorResponse.class);
     System.out.println("Error: " + response.error);
   }
 }</code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.ResourceOwnerCredentialsAccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.UserAgentAuthorizationRequestUrl -->
  <class name="UserAgentAuthorizationRequestUrl" extends="com.google.api.client.auth.oauth2.AbstractAuthorizationRequestUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UserAgentAuthorizationRequestUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[OAuth 2.0 User Agent Flow: URL builder for an authorization web page endpoint
 to allow the end user to authorize the application to access their protected
 resources.
 <p>
 The most commonly-set fields are {@link #clientId}, {@link #redirectUri}, and
 {@link #scope}. After the end-user grants or denies the request, they will be
 redirected to the {@link #redirectUri} with query parameters set by the
 authorization server. Use {@link WebServerAuthorizationResponse} to parse the
 redirect URL.
 <p>
 Sample usage:
 
 <pre>
 <code>static String getAuthorizationUrl() {
   UserAgentAuthorizationRequestUrl builder
       = new UserAgentAuthorizationRequestUrl(BASE_AUTHORIZATION_URL);
   builder.clientId = CLIENT_ID;
   builder.redirectUri = REDIRECT_URL;
   builder.scope = SCOPE;
   return builder.build();
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.UserAgentAuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.UserAgentAuthorizationResponse -->
  <class name="UserAgentAuthorizationResponse" extends="com.google.api.client.auth.oauth2.AbstractAuthorizationResponse"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UserAgentAuthorizationResponse" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param redirectUrl encoded redirect URL
 @throws IllegalArgumentException URI syntax exception]]>
      </doc>
    </constructor>
    <field name="accessToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization) The access token.]]>
      </doc>
    </field>
    <field name="expiresIn" type="java.lang.Long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The duration in seconds of the access token lifetime.]]>
      </doc>
    </field>
    <field name="refreshToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(OPTIONAL) The refresh token.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 User Agent Flow: parses the redirect URL fragment after end user
 grants or denies authorization as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-4.1.1.1"
 >Authorization Server Response</a>
 <p>
 Use {@link AccessProtectedResource} to authorize executed HTTP requests based
 on the {@link #accessToken}.
 <p>
 Sample usage:
 
 <pre>
 <code>static void processRedirectUrl(HttpTransport transport, String redirectUrl)
     throws URISyntaxException {
   UserAgentAuthorizationResponse response
       = new UserAgentAuthorizationResponse(redirectUrl);
   if (response.error != null) {
     throw new RuntimeException("Authorization denied");
   }
   AccessProtectedResource.usingAuthorizationHeader(transport,
       response.accessToken);
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.UserAgentAuthorizationResponse -->
  <!-- start class com.google.api.client.auth.oauth2.VerificationCodeAccessTokenRequest -->
  <class name="VerificationCodeAccessTokenRequest" extends="com.google.api.client.auth.oauth2.AccessTokenRequest"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VerificationCodeAccessTokenRequest" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedAuthorizationServerUrl encoded authorization server URL]]>
      </doc>
    </constructor>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The verification code received from the authorization server.]]>
      </doc>
    </field>
    <field name="redirectUri" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED) The redirection URI used in the initial request.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: request an access token based on a verification
 code as specified in <a
 href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07#section-5.1.1"
 >Verification Code</a>.
 <p>
 The {@link #clientId}, {@link #clientSecret}, {@link #code}, and
 {@link #redirectUri} fields are required. Call {@link #execute()} to execute
 the request.
 <p>
 Sample usage:
 
 <pre>
 <code>static void requestAccessToken(String code, String redirectUrl)
     throws IOException {
   try {
     VerificationCodeAccessTokenRequest request
         = new VerificationCodeAccessTokenRequest();
     request.clientId = CLIENT_ID;
     request.clientSecret = CLIENT_SECRET;
     request.code = code;
     request.redirectUri = redirectUrl;
     AccessTokenResponse response =
         request.execute().parseAs(AccessTokenResponse.class);
     System.out.println("Access token: " + response.accessToken);
   } catch (HttpResponseException e) {
     AccessTokenErrorResponse response =
         e.response.parseAs(AccessTokenErrorResponse.class);
     System.out.println("Error: " + response.error);
   }
 }</code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.VerificationCodeAccessTokenRequest -->
  <!-- start class com.google.api.client.auth.oauth2.WebServerAuthorizationRequestUrl -->
  <class name="WebServerAuthorizationRequestUrl" extends="com.google.api.client.auth.oauth2.AbstractAuthorizationRequestUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WebServerAuthorizationRequestUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: URL builder for an authorization web page to allow
 the end user to authorize the application to access their protected
 resources.
 <p>
 The most commonly-set fields are {@link #clientId}, {@link #redirectUri}, and
 {@link #scope}. After the end-user grants or denies the request, they will be
 redirected to the {@link #redirectUri} with query parameters set by the
 authorization server. Use {@link WebServerAuthorizationResponse} to parse the
 redirect URL.
 <p>
 Sample usage:
 
 <pre>
 <code>@Override
 public void doGet(HttpServletRequest request, HttpServletResponse response)
     throws IOException {
   WebServerAuthorizationUrl builder
       = new WebServerAuthorizationUrl(BASE_AUTHORIZATION_URL);
   builder.clientId = CLIENT_ID;
   builder.redirectUri = REDIRECT_URL;
   builder.scope = SCOPE;
   response.sendRedirect(authorizeUrl.build());
 }</code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.WebServerAuthorizationRequestUrl -->
  <!-- start class com.google.api.client.auth.oauth2.WebServerAuthorizationResponse -->
  <class name="WebServerAuthorizationResponse" extends="com.google.api.client.auth.oauth2.AbstractAuthorizationResponse"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WebServerAuthorizationResponse" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param redirectUrl encoded redirect URL
 @throws IllegalArgumentException URI syntax exception]]>
      </doc>
    </constructor>
    <field name="code" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(REQUIRED if the end user grants authorization) The verification code
 generated by the authorization server. The verification code SHOULD expire
 shortly after it is issued and allowed for a single use. The verification
 code is bound to the client identifier and redirection URI.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[OAuth 2.0 Web Server Flow: parser for the redirect URL after end user grants
 or denies authorization.
 <p>
 To check if the end user grants authorization, check if {@link #error} is
 {@code null}. If the end user grants authorization, the next step is to
 request an access token using {@link VerificationCodeAccessTokenRequest}. Use
 the {@link #code} in {@link VerificationCodeAccessTokenRequest#code}.
 <p>
 Sample usage:
 
 <pre>
 <code>@Override
 public void doGet(HttpServletRequest request, HttpServletResponse response)
     throws IOException {
   StringBuffer fullUrlBuf = request.getRequestURL();
   if (request.getQueryString() != null) {
     fullUrlBuf.append('?').append(request.getQueryString());
   }
   WebServerAuthorizationResponse authResponse =
       new WebServerAuthorizationResponse(fullUrlBuf.toString());
   // check for user-denied error
   if (authResponse.error != null) {
     // authorization denied...
   } else {
     // request access token using authResponse.code...
   }
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.auth.oauth2.WebServerAuthorizationResponse -->
  <doc>
  <![CDATA[OAuth 2.0 authorization as specified in
<a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07">The OAuth 2.0
Protocol (draft-ietf-oauth-v2-07)</a>
(see detailed package specification).

<p>Before using this library, you may need to register your application with
the authorization server to receive a client ID and client secret.</p>

<p>The starting point for each Client Flow depends on which Flow you are
using:</p>

<ul>
  <li>Web Server Flow: {@link
  com.google.api.client.auth.oauth2.WebServerAuthorizationRequestUrl}</li>
  <li>User Agent Flow: {@link
  com.google.api.client.auth.oauth2.UserAgentAuthorizationRequestUrl}</li>
  <li>Username and Password Flow: {@link
  com.google.api.client.auth.oauth2.ResourceOwnerCredentialsAccessTokenRequest}</li>
  <li>Client Credentials Flow: {@link
  com.google.api.client.auth.oauth2.AccessTokenRequest}</li>
  <li>Assertion Flow: {@link
  com.google.api.client.auth.oauth2.AssertionAccessTokenRequest}</li>
</ul>

<p>This package depends on the {@link com.google.api.client.http}, {@link
com.google.api.client.json}, and {@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.escape">
  <!-- start class com.google.api.client.escape.CharEscapers -->
  <class name="CharEscapers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="escapeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URIs. For details
 on escaping URIs, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>.
 
 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0"
 through "9" remain the same.
 <li>The special characters ".", "-", "*", and "_" remain the same.
 <li>The space character " " is converted into a plus sign "+".
 <li>All other characters are converted into one or more bytes using UTF-8
 encoding and each byte is then represented by the 3-character string "%XY",
 where "XY" is the two-digit, uppercase, hexadecimal representation of the
 byte value.
 <ul>
 
 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase
 hexadecimal sequences. From <a href="http://www.ietf.org/rfc/rfc3986.txt">
 RFC 3986</a>:<br>
 <i>"URI producers and normalizers should use uppercase hexadecimal digits
 for all percent-encodings."</i>
 
 <p>
 This escaper has identical behavior to (but is potentially much faster
 than):
 <ul>
 <li>{@link java.net.URLEncoder#encode(String, String)} with the encoding
 name "UTF-8"
 </ul>]]>
      </doc>
    </method>
    <method name="decodeUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Percent-decodes a US-ASCII string into a Unicode string. UTF-8 encoding is
 used to determine what characters are represented by any consecutive
 sequences of the form "%<i>XX</i>".
 
 <p>
 This replaces each occurrence of '+' with a space, ' '. So this method
 should not be used for non application/x-www-form-urlencoded strings such
 as host and path.
 
 @param uri a percent-encoded US-ASCII string
 @return a Unicode string]]>
      </doc>
    </method>
    <method name="escapeUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI path segments.
 For details on escaping URIs, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
 
 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0"
 through "9" remain the same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The subdelimiters "!", "$", "&amp;", "'", "(", ")", "*", ",", ";", and
 "=" remain the same.
 <li>The space character " " is converted into %20.
 <li>All other characters are converted into one or more bytes using UTF-8
 encoding and each byte is then represented by the 3-character string "%XY",
 where "XY" is the two-digit, uppercase, hexadecimal representation of the
 byte value.
 </ul>
 
 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase
 hexadecimal sequences. From <a href="http://www.ietf.org/rfc/rfc3986.txt">
 RFC 3986</a>:<br>
 <i>"URI producers and normalizers should use uppercase hexadecimal digits
 for all percent-encodings."</i>]]>
      </doc>
    </method>
    <method name="escapeUriQuery" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes the string value so it can be safely included in URI query string
 segments. When the query string consists of a sequence of name=value pairs
 separated by &amp;, the names and values should be individually encoded. If
 you escape an entire query string in one pass with this escaper, then the
 "=" and "&amp;" characters used as separators will also be escaped.
 
 <p>
 This escaper is also suitable for escaping fragment identifiers.
 
 <p>
 For details on escaping URIs, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
 
 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0"
 through "9" remain the same.
 <li>The unreserved characters ".", "-", "~", and "_" remain the same.
 <li>The general delimiters "@" and ":" remain the same.
 <li>The path delimiters "/" and "?" remain the same.
 <li>The subdelimiters "!", "$", "'", "(", ")", "*", ",", and ";", remain
 the same.
 <li>The space character " " is converted into %20.
 <li>The equals sign "=" is converted into %3D.
 <li>The ampersand "&amp;" is converted into %26.
 <li>All other characters are converted into one or more bytes using UTF-8
 encoding and each byte is then represented by the 3-character string "%XY",
 where "XY" is the two-digit, uppercase, hexadecimal representation of the
 byte value.
 </ul>
 
 <p>
 <b>Note</b>: Unlike other escapers, URI escapers produce uppercase
 hexadecimal sequences. From <a href="http://www.ietf.org/rfc/rfc3986.txt">
 RFC 3986</a>:<br>
 <i>"URI producers and normalizers should use uppercase hexadecimal digits
 for all percent-encodings."</i>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility functions for dealing with {@code CharEscaper}s, and some commonly
 used {@code CharEscaper} instances.
 
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.escape.CharEscapers -->
  <!-- start class com.google.api.client.escape.Escaper -->
  <class name="Escaper" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Escaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.
 
 <p>
 Note that this method may treat input characters differently depending on
 the specific escaper implementation.
 <ul>
 <li>{@link UnicodeEscaper} handles <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> correctly, including
 surrogate character pairs. If the input is badly formed the escaper should
 throw {@link IllegalArgumentException}.
 </ul>
 
 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if {@code string} contains badly formed
         UTF-16 or cannot be escaped for any other reason]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that converts literal text into a format safe for inclusion in a
 particular context (such as an XML document). Typically (but not always), the
 inverse process of "unescaping" the text is performed automatically by the
 relevant parser.
 
 <p>
 For example, an XML escaper would convert the literal string {@code
 "Foo<Bar>"} into {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from
 being confused with an XML tag. When the resulting XML document is parsed,
 the parser API will return this text as the original literal string {@code
 "Foo<Bar>"}.
 
 <p>
 An {@code Escaper} instance is required to be stateless, and safe when used
 concurrently by multiple threads.
 
 <p>
 Several popular escapers are defined as constants in the class
 {@link CharEscapers}.
 
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.escape.Escaper -->
  <!-- start class com.google.api.client.escape.PercentEscaper -->
  <class name="PercentEscaper" extends="com.google.api.client.escape.UnicodeEscaper"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PercentEscaper" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a URI escaper with the specified safe characters and optional
 handling of the space character.
 
 @param safeChars a non null string specifying additional safe characters
        for this escaper (the ranges 0..9, a..z and A..Z are always safe and
        should not be specified here)
 @param plusForSpace true if ASCII space should be escaped to {@code +}
        rather than {@code %20}
 @throws IllegalArgumentException if any of the parameters were invalid]]>
      </doc>
    </constructor>
    <method name="nextEscapeIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <method name="escape" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Escapes the given Unicode code point in UTF-8.]]>
      </doc>
    </method>
    <field name="SAFECHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of safe characters that mimics the behavior of
 {@link java.net.URLEncoder}.
 
 TODO: Fix escapers to be compliant with RFC 3986]]>
      </doc>
    </field>
    <field name="SAFEPATHCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI path
 segments, as specified in RFC 3986. Note that some of these characters do
 need to be escaped when used in other parts of the URI.]]>
      </doc>
    </field>
    <field name="SAFEQUERYSTRINGCHARS_URLENCODER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A string of characters that do not need to be encoded when used in URI
 query strings, as specified in RFC 3986. Note that some of these characters
 do need to be escaped when used in other parts of the URI.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A {@code UnicodeEscaper} that escapes some set of Java characters using the
 URI percent encoding scheme. The set of safe characters (those which remain
 unescaped) can be specified on construction.
 
 <p>
 For details on escaping URIs for use in web pages, see section 2.4 of <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>.
 
 <p>
 When encoding a String, the following rules apply:
 <ul>
 <li>The alphanumeric characters "a" through "z", "A" through "Z" and "0"
 through "9" remain the same.
 <li>Any additionally specified safe characters remain the same.
 <li>If {@code plusForSpace} was specified, the space character " " is
 converted into a plus sign "+".
 <li>All other characters are converted into one or more bytes using UTF-8
 encoding and each byte is then represented by the 3-character string "%XY",
 where "XY" is the two-digit, uppercase, hexadecimal representation of the
 byte value.
 </ul>
 
 <p>
 RFC 2396 specifies the set of unreserved characters as "-", "_", ".", "!",
 "~", "*", "'", "(" and ")". It goes on to state:
 
 <p>
 <i>Unreserved characters can be escaped without changing the semantics of the
 URI, but this should not be done unless the URI is being used in a context
 that does not allow the unescaped character to appear.</i>
 
 <p>
 For performance reasons the only currently supported character encoding of
 this class is UTF-8.
 
 <p>
 <b>Note</b>: This escaper produces uppercase hexadecimal sequences. From <a
 href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>:<br>
 <i>"URI producers and normalizers should use uppercase hexadecimal digits for
 all percent-encodings."</i>
 
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.escape.PercentEscaper -->
  <!-- start class com.google.api.client.escape.UnicodeEscaper -->
  <class name="UnicodeEscaper" extends="com.google.api.client.escape.Escaper"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnicodeEscaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="escape" return="char[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cp" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of the given Unicode code point, or {@code null}
 if this code point does not need to be escaped. When called as part of an
 escaping operation, the given code point is guaranteed to be in the range
 {@code 0 <= cp <= Character#MAX_CODE_POINT}.
 
 <p>
 If an empty array is returned, this effectively strips the input character
 from the resulting text.
 
 <p>
 If the character does not need to be escaped, this method should return
 {@code null}, rather than an array containing the character representation
 of the code point. This enables the escaping algorithm to perform more
 efficiently.
 
 <p>
 If the implementation of this method cannot correctly handle a particular
 code point then it should either throw an appropriate runtime exception or
 return a suitable replacement character. It must never silently discard
 invalid input as this may constitute a security risk.
 
 @param cp the Unicode code point to escape if necessary
 @return the replacement characters, or {@code null} if no escaping was
         needed]]>
      </doc>
    </method>
    <method name="nextEscapeIndex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Scans a sub-sequence of characters from a given {@link CharSequence},
 returning the index of the next character that requires escaping.
 
 <p>
 <b>Note:</b> When implementing an escaper, it is a good idea to override
 this method for efficiency. The base class implementation determines
 successive Unicode code points and invokes {@link #escape(int)} for each of
 them. If the semantics of your escaper are such that code points in the
 supplementary range are either all escaped or all unescaped, this method
 can be implemented more efficiently using {@link CharSequence#charAt(int)}.
 
 <p>
 Note however that if your escaper does not escape characters in the
 supplementary range, you should either continue to validate the correctness
 of any surrogate characters encountered or provide a clear warning to users
 that your escaper does not validate its input.
 
 <p>
 See {@link PercentEscaper} for an example.
 
 @param csq a sequence of characters
 @param start the index of the first character to be scanned
 @param end the index immediately after the last character to be scanned
 @throws IllegalArgumentException if the scanned sub-sequence of {@code csq}
         contains invalid surrogate pairs]]>
      </doc>
    </method>
    <method name="escape" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string.
 
 <p>
 If you are escaping input in arbitrary successive chunks, then it is not
 generally safe to use this method. If an input string ends with an
 unmatched high surrogate character, then this method will throw
 {@link IllegalArgumentException}. You should ensure your input is valid <a
 href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> before calling this
 method.
 
 @param string the literal string to be escaped
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are
         encountered]]>
      </doc>
    </method>
    <method name="escapeSlow" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the escaped form of a given literal string, starting at the given
 index. This method is called by the {@link #escape(String)} method when it
 discovers that escaping is required. It is protected to allow subclasses to
 override the fastpath escaping function to inline their escaping test.
 
 <p>
 This method is not reentrant and may only be invoked by the top level
 {@link #escape(String)} method.
 
 @param s the literal string to be escaped
 @param index the index to start escaping from
 @return the escaped form of {@code string}
 @throws NullPointerException if {@code string} is null
 @throws IllegalArgumentException if invalid surrogate characters are
         encountered]]>
      </doc>
    </method>
    <method name="codePointAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode code point of the character at the given index.
 
 <p>
 Unlike {@link Character#codePointAt(CharSequence, int)} or
 {@link String#codePointAt(int)} this method will never fail silently when
 encountering an invalid surrogate pair.
 
 <p>
 The behaviour of this method is as follows:
 <ol>
 <li>If {@code index >= end}, {@link IndexOutOfBoundsException} is thrown.
 <li><b>If the character at the specified index is not a surrogate, it is
 returned.</b>
 <li>If the first character was a high surrogate value, then an attempt is
 made to read the next character.
 <ol>
 <li><b>If the end of the sequence was reached, the negated value of the
 trailing high surrogate is returned.</b>
 <li><b>If the next character was a valid low surrogate, the code point
 value of the high/low surrogate pair is returned.</b>
 <li>If the next character was not a low surrogate value, then
 {@link IllegalArgumentException} is thrown.
 </ol>
 <li>If the first character was a low surrogate value,
 {@link IllegalArgumentException} is thrown.
 </ol>
 
 @param seq the sequence of characters from which to decode the code point
 @param index the index of the first character to decode
 @param end the index beyond the last valid character to decode
 @return the Unicode code point for the given index or the negated value of
         the trailing high surrogate character at the end of the sequence]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link Escaper} that converts literal text into a format safe for
 inclusion in a particular context (such as an XML document). Typically (but
 not always), the inverse process of "unescaping" the text is performed
 automatically by the relevant parser.
 
 <p>
 For example, an XML escaper would convert the literal string {@code
 "Foo<Bar>"} into {@code "Foo&lt;Bar&gt;"} to prevent {@code "<Bar>"} from
 being confused with an XML tag. When the resulting XML document is parsed,
 the parser API will return this text as the original literal string {@code
 "Foo<Bar>"}.
 
 <p>
 As there are important reasons, including potential security issues, to
 handle Unicode correctly if you are considering implementing a new escaper
 you should favor using UnicodeEscaper wherever possible.
 
 <p>
 A {@code UnicodeEscaper} instance is required to be stateless, and safe when
 used concurrently by multiple threads.
 
 <p>
 Several popular escapers are defined as constants in the class
 {@link CharEscapers}. To create your own escapers extend this class and
 implement the {@link #escape(int)} method.
 
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.escape.UnicodeEscaper -->
  <doc>
  <![CDATA[Character escaping utilities.

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis">
  <!-- start class com.google.api.client.googleapis.GoogleHeaders -->
  <class name="GoogleHeaders" extends="com.google.api.client.http.HttpHeaders"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleHeaders"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setSlugFromFileName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Slug"} header for the given file name, properly escaping
 the header value. See <a
 href="http://tools.ietf.org/html/rfc5023#section-9.7">The Slug Header</a>.]]>
      </doc>
    </method>
    <method name="setApplicationName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationName" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "User-Agent"} header for the given application name of the
 form {@code "[company-id]-[app-name]-[app-version]"} into the given HTTP
 headers.]]>
      </doc>
    </method>
    <method name="setDeveloperId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="developerId" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #gdataKey} header using the given developer ID.]]>
      </doc>
    </method>
    <method name="setGoogleLogin"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the Google Login {@code "Authorization"} header for the given
 authentication token.]]>
      </doc>
    </method>
    <method name="getGoogleLoginValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authToken" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns Google Login {@code "Authorization"} header value based on the
 given authentication token.]]>
      </doc>
    </method>
    <field name="SLUG_ESCAPER" type="com.google.api.client.escape.PercentEscaper"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Escaper for the {@link #slug} header.]]>
      </doc>
    </field>
    <field name="gdataVersion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "GData-Version"} header.]]>
      </doc>
    </field>
    <field name="slug" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Escaped {@code "Slug"} header value, which must be escaped using
 {@link #SLUG_ESCAPER}.

 @see #setSlugFromFileName(String)]]>
      </doc>
    </field>
    <field name="gdataClient" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "X-GData-Client"} header.]]>
      </doc>
    </field>
    <field name="gdataKey" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "X-GData-Key"} header, which must be of the form {@code
 "key=[developerId]"}.

 @see #setDeveloperId(String)]]>
      </doc>
    </field>
    <field name="googAcl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-acl"} header that lets you apply predefined (canned) ACLs to
 a bucket or object when you upload it or create it.]]>
      </doc>
    </field>
    <field name="googCopySource" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-copy-source"} header that specifies the destination bucket
 and object for a copy operation.]]>
      </doc>
    </field>
    <field name="googCopySourceIfMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-copy-source-if-match"} header that specifies the conditions
 for a copy operation.]]>
      </doc>
    </field>
    <field name="googCopySourceIfNoneMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-copy-source-if-none-match"} header that specifies the
 conditions for a copy operation.]]>
      </doc>
    </field>
    <field name="googCopySourceIfModifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-copy-source-if-modified-since"} header that specifies the
 conditions for a copy operation.]]>
      </doc>
    </field>
    <field name="googCopySourceIfUnmodifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-copy-source-if-unmodified-since"} header that specifies the
 conditions for a copy operation.]]>
      </doc>
    </field>
    <field name="googDate" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-date"} header that specifies a time stamp for authenticated
 requests.]]>
      </doc>
    </field>
    <field name="googMetadataDirective" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "x-goog-metadata-directive"} header that specifies metadata handling
 during a copy operation.]]>
      </doc>
    </field>
    <field name="methodOverride" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "X-HTTP-Method-Override"} header.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP headers for Google API's.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.GoogleHeaders -->
  <!-- start class com.google.api.client.googleapis.GoogleTransport -->
  <class name="GoogleTransport" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.api.client.http.HttpTransport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates and returns a new HTTP transport with basic default behaviors for
 working with Google API's.
 <p>
 Includes:
 <ul>
 <li>Setting the {@link HttpTransport#defaultHeaders} to a new instance of
 {@link GoogleHeaders}.</li>
 <li>Adding a {@link MethodOverrideIntercepter} as the first HTTP execute
 intercepter to use HTTP method override for unsupported HTTP methods (calls
 {@link MethodOverrideIntercepter#setAsFirstFor(HttpTransport)}.</li>
 </ul>
 <p>
 Sample usage:
 
 <pre>
 <code>
  static HttpTransport createTransport() {
    HttpTransport transport = GoogleTransport.create();
    GoogleHeaders headers = (GoogleHeaders) transport.defaultHeaders;
    headers.setApplicationName("acme-rocket-2");
    headers.gdataVersion = "2";
    return transport;
  }
 </code>
 </pre>
 
 @return HTTP transport]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP transport for Google API's. It's only purpose is to allow for method
 overriding when the firewall does not accept DELETE, PATCH or PUT methods.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.GoogleTransport -->
  <!-- start class com.google.api.client.googleapis.GoogleUrl -->
  <class name="GoogleUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GoogleUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedUrl encoded URL, including any existing query parameters that
        should be parsed]]>
      </doc>
    </constructor>
    <field name="prettyprint" type="java.lang.Boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to pretty print the output.]]>
      </doc>
    </field>
    <field name="alt" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Alternate wire format.]]>
      </doc>
    </field>
    <field name="fields" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Partial fields mask.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic Google URL providing for some common query parameters used in Google
 API's such as the {@link #alt} and {@link #fields} parameters.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.GoogleUrl -->
  <!-- start class com.google.api.client.googleapis.MethodOverrideIntercepter -->
  <class name="MethodOverrideIntercepter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpExecuteIntercepter"/>
    <constructor name="MethodOverrideIntercepter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
    </method>
    <method name="setAsFirstFor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Sets this as the first HTTP request execute intercepter for the given HTTP
 transport.]]>
      </doc>
    </method>
    <field name="overriddenMethods" type="java.util.HashSet&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP methods that need to be overridden.
 <p>
 Any HTTP method not supported by the low level HTTP transport returned by
 {@link HttpTransport#useLowLevelHttpTransport()} is automatically added.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP request execute intercepter for Google API's that wraps HTTP requests --
 other than GET or POST -- inside of a POST request and uses {@code
 "X-HTTP-Method-Override"} header to specify the actual HTTP method.
 <p>
 It is useful when a firewall only allows the GET and POST methods, or if the
 underlying HTTP library ({@link LowLevelHttpTransport}) does not support the
 HTTP method.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.MethodOverrideIntercepter -->
  <doc>
  <![CDATA[Google API's.

<p>This package depends on the {@link com.google.api.client.escape} and
{@link com.google.api.client.http}, and {@link com.google.api.client.util}
packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.auth">
  <!-- start class com.google.api.client.googleapis.auth.AuthKeyValueParser -->
  <class name="AuthKeyValueParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="com.google.api.client.googleapis.auth.AuthKeyValueParser"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Singleton instance.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP parser for Google response to an Authorization request.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.AuthKeyValueParser -->
  <doc>
  <![CDATA[Utilities for Google's authentication methods as described in
<a href="http://code.google.com/apis/accounts/docs/GettingStarted.html">Getting
Started with Account Authorization</a>
.

<p>This package depends on the {@link com.google.api.client.http} and {@link
com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.auth.authsub">
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSub -->
  <class name="AuthSub" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getAuthorizationHeaderValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@code AuthSub} authorization header value based on the given
 authentication token.]]>
      </doc>
    </method>
    <method name="getAuthorizationHeaderValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="java.lang.String"/>
      <param name="privateKey" type="java.security.PrivateKey"/>
      <param name="requestMethod" type="java.lang.String"/>
      <param name="requestUrl" type="java.lang.String"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Returns {@code AuthSub} authorization header value based on the given
 authentication token, private key, request method, and request URL.
 
 @throws GeneralSecurityException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSub -->
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSubHelper -->
  <class name="AuthSubHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthSubHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setPrivateKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateKey" type="java.security.PrivateKey"/>
      <doc>
      <![CDATA[Sets to the given private key for secure AuthSub or {@code null} for
 non-secure AuthSub.
 <p>
 Updates the authorization header of the Google transport (set using
 {@link #setTransport(HttpTransport)}).]]>
      </doc>
    </method>
    <method name="setTransport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Sets to the given Google transport whose authorization header to set or
 {@code null} to ignore (for example if using an alternative HTTP library).
 <p>
 Updates the authorization header of the Google transport.]]>
      </doc>
    </method>
    <method name="setToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets to the given single-use or session token (or resets any existing token
 if {@code null}).
 <p>
 Any previous stored single-use or session token will be forgotten. Updates
 the authorization header of the Google transport (set using
 {@link #setTransport(HttpTransport)}).]]>
      </doc>
    </method>
    <method name="exchangeForSessionToken" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Exchanges the single-use token for a session token as described in <a href=
 "http://code.google.com/apis/accounts/docs/AuthSub.html#AuthSubSessionToken"
 >AuthSubSessionToken</a>. Sets the authorization header of the Google
 transport using the session token, and automatically sets the token used by
 this instance using {@link #setToken(String)}.
 <p>
 Note that Google allows at most 10 session tokens per use per web
 application, so the session token for each user must be persisted.
 
 @return session token
 @throws HttpResponseException if the authentication response has an error
         code
 @throws IOException some other kind of I/O exception]]>
      </doc>
    </method>
    <method name="revokeSessionToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Revokes the session token. Clears any existing authorization header of the
 Google transport and automatically resets the token by calling {@code
 setToken(null)}.
 <p>
 See <a href=
 "http://code.google.com/apis/accounts/docs/AuthSub.html#AuthSubRevokeToken"
 >AuthSubRevokeToken</a> for protocol details.
 
 @throws HttpResponseException if the authentication response has an error
         code
 @throws IOException some other kind of I/O exception]]>
      </doc>
    </method>
    <method name="requestTokenInfo" return="com.google.api.client.googleapis.auth.authsub.AuthSubHelper.TokenInfoResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retries the token information as described in <a href=
 "http://code.google.com/apis/accounts/docs/AuthSub.html#AuthSubTokenInfo"
 >AuthSubTokenInfo</a>.
 
 @throws HttpResponseException if the authentication response has an error
         code
 @throws IOException some other kind of I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[AuthSub token manager for a single user.
 <p>
 To properly initialize, set:
 <ul>
 <li>{@link #setToken}: single-use or session token (required)</li>
 <li>{@link #transport}: Google transport (recommended)</li>
 <li>{@link #privateKey}: private key for secure AuthSub (recommended)</li>
 </ul>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSubHelper -->
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSubHelper.SessionTokenResponse -->
  <class name="AuthSubHelper.SessionTokenResponse" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthSubHelper.SessionTokenResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="sessionToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Key/value data to parse a success response for an AuthSubSessionToken
 request.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSubHelper.SessionTokenResponse -->
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSubHelper.TokenInfoResponse -->
  <class name="AuthSubHelper.TokenInfoResponse" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthSubHelper.TokenInfoResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="secure" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="target" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Key/value data to parse a success response for an AuthSubTokenInfo request.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSubHelper.TokenInfoResponse -->
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSubSingleUseTokenRequestUrl -->
  <class name="AuthSubSingleUseTokenRequestUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthSubSingleUseTokenRequestUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="nextUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(required) URL the user should be redirected to after a successful login.
 This value should be a page on the web application site, and can include
 query parameters.]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(required) URL identifying the service(s) to be accessed; see documentation
 for the service for the correct value(s). The resulting token enables
 access to the specified service(s) only. To specify more than one scope,
 list each one separated with a space (encodes as "%20").]]>
      </doc>
    </field>
    <field name="template" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optionally use {@code "mobile"} to for a mobile version of the approval
 page or {@code null} for normal.]]>
      </doc>
    </field>
    <field name="hostedDomain" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional value identifying a particular Google Apps (hosted) domain account
 to be accessed (for example, 'mycollege.edu') or {@code null} or {@code
 "default"} for a regular Google account ('username@gmail.com').]]>
      </doc>
    </field>
    <field name="language" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional ISO 639 country code identifying what language the approval page
 should be translated in (for example, 'hl=en' for English) or {@code null}
 for the user's selected language.]]>
      </doc>
    </field>
    <field name="secure" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(optional) Boolean flag indicating whether the authorization transaction
 should issue a secure token (1) or a non-secure token (0). Secure tokens
 are available to registered applications only.]]>
      </doc>
    </field>
    <field name="session" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(optional) Boolean flag indicating whether the one-time-use token may be
 exchanged for a session token (1) or not (0).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic URL that builds an AuthSub request URL to retrieve a single-use
 token. See <a href=
 "http://code.google.com/apis/accounts/docs/AuthSub.html#AuthSubRequest"
 >documentation</a>.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSubSingleUseTokenRequestUrl -->
  <!-- start class com.google.api.client.googleapis.auth.authsub.AuthSubSingleUseTokenRequestUrl.ResponseUrl -->
  <class name="AuthSubSingleUseTokenRequestUrl.ResponseUrl" extends="com.google.api.client.http.GenericUrl"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthSubSingleUseTokenRequestUrl.ResponseUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="token" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Generic URL with a token parameter that can be used to extract the AuthSub
 single-use token from the AuthSubRequest response.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.authsub.AuthSubSingleUseTokenRequestUrl.ResponseUrl -->
  <doc>
  <![CDATA[Google's legacy AuthSub authorization as specified in
<a href="http://code.google.com/apis/accounts/docs/AuthSub.html">AuthSub for
Web Applications</a>
.

<p>This package depends on the {@link com.google.api.client.auth}, {@link
com.google.api.client.googleapis}, {@link
com.google.api.client.googleapis.auth}, {@link com.google.api.client.http} and
{@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.auth.clientlogin">
  <!-- start class com.google.api.client.googleapis.auth.clientlogin.ClientLogin -->
  <class name="ClientLogin" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientLogin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="authenticate" return="com.google.api.client.googleapis.auth.clientlogin.ClientLogin.Response"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="HttpResponseException" type="com.google.api.client.http.HttpResponseException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Authenticates based on the provided field values.

 @throws HttpResponseException if the authentication response has an error
         code, such as for a CAPTCHA challenge. Call {@code 
         exception.response.parseAs(ClientLoginAuthenticator.ErrorInfo.class)
         * } to parse the response.
 @throws IOException some other kind of I/O exception]]>
      </doc>
    </method>
    <field name="applicationName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="authTokenType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="username" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="password" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="accountType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Type of account to request authorization for. Possible values are:

 <ul>
 <li>GOOGLE (get authorization for a Google account only)</li>
 <li>HOSTED (get authorization for a hosted account only)</li>
 <li>HOSTED_OR_GOOGLE (get authorization first for a hosted account; if
 attempt fails, get authorization for a Google account)</li>
 </ul>

 Use HOSTED_OR_GOOGLE if you're not sure which type of account you want
 authorization for. If the user information matches both a hosted and a
 Google account, only the hosted account is authorized.

 @since 1.1]]>
      </doc>
    </field>
    <field name="captchaToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="captchaAnswer" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Client Login authentication method as described in <a
 href="http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html"
 >ClientLogin for Installed Applications</a>.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.clientlogin.ClientLogin -->
  <!-- start class com.google.api.client.googleapis.auth.clientlogin.ClientLogin.ErrorInfo -->
  <class name="ClientLogin.ErrorInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientLogin.ErrorInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="error" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="url" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="captchaToken" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="captchaUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Key/value data to parse an error response.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.clientlogin.ClientLogin.ErrorInfo -->
  <!-- start class com.google.api.client.googleapis.auth.clientlogin.ClientLogin.Response -->
  <class name="ClientLogin.Response" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientLogin.Response"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAuthorizationHeaderValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setAuthorizationHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="googleTransport" type="com.google.api.client.http.HttpTransport"/>
      <doc>
      <![CDATA[Sets the authorization header for the given Google transport using the
 authentication token.]]>
      </doc>
    </method>
    <field name="auth" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Key/value data to parse a success response.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.clientlogin.ClientLogin.Response -->
  <doc>
  <![CDATA[Google's legacy ClientLogin authentication method as described in
<a href="http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html">ClientLogin
for Installed Applications</a>
.

<p>This package depends on the {@link com.google.api.client.googleapis},
{@link com.google.api.client.googleapis.auth}, {@link
com.google.api.client.http}, and {@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.auth.oauth">
  <!-- start class com.google.api.client.googleapis.auth.oauth.GoogleOAuthAuthorizeTemporaryTokenUrl -->
  <class name="GoogleOAuthAuthorizeTemporaryTokenUrl" extends="com.google.api.client.auth.oauth.OAuthAuthorizeTemporaryTokenUrl"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleOAuthAuthorizeTemporaryTokenUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="template" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optionally use {@code "mobile"} to for a mobile version of the approval
 page or {@code null} for normal.]]>
      </doc>
    </field>
    <field name="hostedDomain" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional value identifying a particular Google Apps (hosted) domain account
 to be accessed (for example, 'mycollege.edu') or {@code null} or {@code
 "default"} for a regular Google account ('username@gmail.com').]]>
      </doc>
    </field>
    <field name="language" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional ISO 639 country code identifying what language the approval page
 should be translated in (for example, 'hl=en' for English) or {@code null}
 for the user's selected language.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Google OAuth 1.0a URL builder for a Google Accounts web page to allow the end
 user to authorize the temporary token.
 <p>
 This only supports Google API's that use {@code
 "https://www.google.com/accounts/OAuthAuthorizeToken"} for authorizing
 temporary tokens.
 </p>
 <p>
 The {@link #temporaryToken} should be set from the
 {@link OAuthCredentialsResponse#token} returned by
 {@link GoogleOAuthGetTemporaryToken#execute()}. Use {@link #build()} to build
 the authorization URL. If a {@link OAuthGetTemporaryToken#callback} was
 specified, after the end user grants the authorization, the Google
 authorization server will redirect to that callback URL. To parse the
 response, use {@link OAuthCallbackUrl}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.oauth.GoogleOAuthAuthorizeTemporaryTokenUrl -->
  <!-- start class com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation -->
  <class name="GoogleOAuthDomainWideDelegation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpExecuteIntercepter"/>
    <constructor name="GoogleOAuthDomainWideDelegation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
    </method>
    <method name="signRequests"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="parameters" type="com.google.api.client.auth.oauth.OAuthParameters"/>
      <doc>
      <![CDATA[Performs OAuth HTTP request signing via query parameter for the {@code
 xoauth_requestor_id} and the {@code Authorization} header as the final HTTP
 request execute intercepter for the given HTTP request execute manager.
 
 @param transport HTTP transport
 @param parameters OAuth parameters; the {@link OAuthParameters#signer} and
        {@link OAuthParameters#consumerKey} should be set]]>
      </doc>
    </method>
    <field name="requestorId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Email address of the user whose data you are trying to access.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Google's OAuth domain-wide delegation requires an e-mail address of the user
 whose data you are trying to access via {@link #requestorId} on every HTTP
 request.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation -->
  <!-- start class com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation.Url -->
  <class name="GoogleOAuthDomainWideDelegation.Url" extends="com.google.api.client.googleapis.GoogleUrl"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleOAuthDomainWideDelegation.Url" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param encodedUrl encoded URL, including any existing query parameters
        that should be parsed]]>
      </doc>
    </constructor>
    <field name="requestorId" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Email address of the user whose data you are trying to access.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic URL that extends {@link GoogleUrl} and also provides the
 {@link #requestorId} parameter.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation.Url -->
  <!-- start class com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetAccessToken -->
  <class name="GoogleOAuthGetAccessToken" extends="com.google.api.client.auth.oauth.OAuthGetAccessToken"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleOAuthGetAccessToken"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="revokeAccessToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="com.google.api.client.auth.oauth.OAuthParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Revokes the long-lived access token.
 
 @param parameters OAuth parameters
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic Google OAuth 1.0a URL to request to exchange the temporary
 credentials token (or "request token") for a long-lived credentials token (or
 "access token") from the Google Authorization server.
 <p>
 Use {@link #execute()} to execute the request. The long-lived access token
 acquired with this request is found in {@link OAuthCredentialsResponse#token}
 . This token must be stored. It may then be used to authorize HTTP requests
 to protected resources in Google services by setting the
 {@link OAuthParameters#token}, and invoking
 {@link OAuthParameters#signRequestsUsingAuthorizationHeader(HttpTransport)}.
 <p>
 To revoke the stored access token, use {@link #revokeAccessToken}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetAccessToken -->
  <!-- start class com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetTemporaryToken -->
  <class name="GoogleOAuthGetTemporaryToken" extends="com.google.api.client.auth.oauth.OAuthGetTemporaryToken"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleOAuthGetTemporaryToken"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createParameters" return="com.google.api.client.auth.oauth.OAuthParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="displayName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional string identifying the application or {@code null} for none. This
 string is displayed to end users on Google's authorization confirmation
 page. For registered applications, the value of this parameter overrides
 the name set during registration and also triggers a message to the user
 that the identity can't be verified. For unregistered applications, this
 parameter enables them to specify an application name, In the case of
 unregistered applications, if this parameter is not set, Google identifies
 the application using the URL value of oauth_callback; if neither parameter
 is set, Google uses the string "anonymous".]]>
      </doc>
    </field>
    <field name="scope" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required URL identifying the service(s) to be accessed. The resulting token
 enables access to the specified service(s) only. Scopes are defined by each
 Google service; see the service's documentation for the correct value. To
 specify more than one scope, list each one separated with a space.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic Google OAuth 1.0a URL to request a temporary credentials token (or
 "request token") from the Google Authorization server.
 <p>
 Use {@link #execute()} to execute the request. Google verifies that the
 requesting application has been registered with Google or is using an
 approved signature (in the case of installed applications). The temporary
 token acquired with this request is found in
 {@link OAuthCredentialsResponse#token} . This temporary token is used in
 {@link GoogleOAuthAuthorizeTemporaryTokenUrl#temporaryToken} to direct the
 end user to a Google Accounts web page to allow the end user to authorize the
 temporary token.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetTemporaryToken -->
  <doc>
  <![CDATA[Google's additions to OAuth 1.0a authorization as specified in
<a href="http://code.google.com/apis/accounts/docs/OAuth_ref.html">Google's
OAuth API Reference </a>
(see detailed package specification).

<h2>Package Specification</h2>

<p>Before using this library, you need to set up your application as
follows:</p>
<ol>
  <li>For a web application, you should first register your application at
  the <a
    href="http://code.google.com/apis/accounts/docs/RegistrationForWebAppsAuto.html">registration
  page</a>. You will be provided with two pieces of information you will need:
  <ul>
    <li>OAuth Consumer Key: use this as the {@code consumerKey} on every
    OAuth request, for example in {@link
    com.google.api.client.auth.oauth.AbstractOAuthGetToken#consumerKey}.</li>
    <li>OAuth Consumer Secret: use this as the {@link
    com.google.api.client.auth.oauth.OAuthHmacSigner#clientSharedSecret} when
    using the {@code "HMAC-SHA1"} signature method.</li>
  </ul>
  </li>
  <li>For an installed application, an unregistered web application, or a
  web application running on localhost, you must use the {@code "HMAC-SHA1"}
  signature method. Use {@code "anonymous"} for the {@code consumerKey} and
  {@code clientSharedSecret}.</li>
  <li>For the {@code "HMAC-SHA1"} signature method, use {@link
  com.google.api.client.auth.oauth.OAuthHmacSigner}.</li>
  <li>For the {@code "RSA-SHA1"} signature method, use {@link
  com.google.api.client.auth.oauth.OAuthRsaSigner}. See the instructions for <a
    href="http://code.google.com/apis/gdata/docs/auth/oauth.html#GeneratingKeyCert">generating
  a self-signing private key and public certificate </a>.</li>
</ol>
<p>After the set up has been completed, the typical application flow is:</p>
<ol>
  <li>Request a temporary credentials token ("request token") from the
  Google Authorization server using {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetTemporaryToken}. A
  callback URL should be specified for web applications, but does not need to be
  specified for installed applications.</li>
  <li>Direct the end user to a Google Accounts web page to allow the end
  user to authorize the temporary token using using {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthAuthorizeTemporaryTokenUrl}.</li>
  <li>After the user has granted the authorization:
  <ul>
    <li>For web applications, the user's browser will be redirected to the
    callback URL which may be parsed using {@link
    com.google.api.client.auth.oauth.OAuthCallbackUrl}.</li>
    <li>For installed applications, use {@code ""} for the verification
    code.</li>
  </ul>
  </li>
  <li>Request to exchange the temporary token for a long-lived access token
  from the Google Authorization server using {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetAccessToken}. This
  access token must be stored.</li>
  <li>Use the stored access token to authorize HTTP requests to protected
  resources in Google services by setting the {@link
  com.google.api.client.auth.oauth.OAuthParameters#token} and invoking {@link
  com.google.api.client.auth.oauth.OAuthParameters#signRequestsUsingAuthorizationHeader}.</li>
  <li>For 2-legged OAuth, use {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation}
  as a request execute intercepter to set the e-mail address of the user on
  every HTTP request, or {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthDomainWideDelegation.Url}
  as a generic URL builder with the requestor ID parameter.</li>
  <li>To revoke an access token, use {@link
  com.google.api.client.googleapis.auth.oauth.GoogleOAuthGetAccessToken#revokeAccessToken}.
  Users can also manually revoke tokens from Google's <a
    href="https://www.google.com/accounts/IssuedAuthSubTokens">change
  authorized websites</a> page.</li>
</ol>
For example:
<pre><code>
import com.google.api.client.auth.*;
import com.google.api.client.auth.oauth.*;
import com.google.api.client.googleapis.*;
import com.google.api.client.googleapis.auth.oauth.*;
import com.google.api.client.http.*;

import java.io.*;
import java.net.*;
import java.security.*;
import java.util.*;

import javax.servlet.http.*;

public class PicasaSample extends HttpServlet {

  private static final String CONSUMER_KEY = "...";

  /**
   * OAuth type. This is only needed for a general-purpose sample. In a real
   * application, normally only one kind of auth is used.
   */
  enum OAuthType {
    REGISTERED_RSA, REGISTERED_HMAC, UNREGISTERED_HMAC
  }

  static final OAuthType OAUTH_TYPE = OAuthType.REGISTERED_RSA;

  private static final String CONSUMER_KEY =
      OAUTH_TYPE == OAuthType.UNREGISTERED_HMAC ? "anonymous" : "...";

  /**
   * In-memory access token store. But this is bad practice! For example, if the
   * process dies, all tokens would be lost. Instead, the long-lived access
   * token credentials should be stored in a long-lived location for example in
   * a database.
   */
  static Map&lt;String , TokenInfo&gt; OAUTH_TOKENS = new HashMap&lt;String, TokenInfo&gt;();

  static final class TokenInfo {
    final boolean temporary;
    final String token;
    final String tokenSecret;

    TokenInfo(OAuthCredentialsResponse response) {
      this.token = response.token;
      this.tokenSecret = response.tokenSecret;
      this.temporary = response.callbackConfirmed != null;
    }

    OAuthParameters createParameters() throws IOException {
      OAuthParameters result = new OAuthParameters();
      result.consumerKey = CONSUMER_KEY;
      result.signer = createSigner(this);
      result.token = token;
      return result;
    }
  }

  private static TokenInfo execute(AbstractOAuthGetToken request)
      throws IOException {
    OAuthCredentialsResponse response = request.execute(); 
    TokenInfo result = new TokenInfo(response);
    OAUTH_TOKENS.put(getCurrentUserId(), result);
    return result;
  }

  private static final String SCOPE = "http://picasaweb.google.com/data";

  public void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException {
    PrintWriter writer = response.getWriter();
    GoogleTransport transport = new GoogleTransport();
    transport.applicationName = "...";
    transport.setVersionHeader(PicasaWebAlbums.VERSION);
    try {
      String thisURL = request.getRequestURI();
      String userId = getCurrentUserId();
      TokenInfo tokenInfo = OAUTH_TOKENS.get(userId);
      StringBuffer fullUrlBuf = request.getRequestURL();
      if (request.getQueryString() != null) {
        fullUrlBuf.append('?').append(request.getQueryString());
      }
      String fullUrl = fullUrlBuf.toString();
      OAuthCallbackUrl authorizeResponse = new OAuthCallbackUrl(fullUrl);
      if (tokenInfo != null && tokenInfo.temporary
          && authorizeResponse.verifier == null) {
        tokenInfo = null;
      }
      OAuthSigner signer = createSigner(tokenInfo);
      if (tokenInfo == null) {
        GoogleOAuthGetTemporaryToken requestToken =
            new GoogleOAuthGetTemporaryToken();
        requestToken.signer = signer;
        requestToken.consumerKey = CONSUMER_KEY;
        requestToken.scope = SCOPE;
        requestToken.callback = request.getRequestURL().toString();
        tokenInfo = execute(requestToken);
        GoogleOAuthAuthorizeTemporaryTokenUrl authorizeUrl =
            new GoogleOAuthAuthorizeTemporaryTokenUrl();
        authorizeUrl.temporaryToken = tokenInfo.token;
        response.sendRedirect(authorizeUrl.build());
        return;
      }
      if (tokenInfo.temporary) {
        GoogleOAuthGetAccessToken accessToken =
            new GoogleOAuthGetAccessToken();
        accessToken.temporaryToken = tokenInfo.token;
        accessToken.signer = signer;
        accessToken.consumerKey = CONSUMER_KEY;
        accessToken.verifier = authorizeResponse.verifier;
        tokenInfo = execute(accessToken);
        signer = createSigner(tokenInfo);
      }
      tokenInfo.createParameters().signRequestsUsingAuthorizationHeader(
          transport);
      run(writer, transport);
    } catch (Exception e) {
      handleException(writer, e);
    }
  }

  private static OAuthSigner createSigner(TokenInfo tokenInfo)
      throws IOException {
    if (OAUTH_TYPE == OAuthType.REGISTERED_RSA) {
      OAuthRsaSigner result = new OAuthRsaSigner();
      result.privateKey = getPrivateKey();
      return result;
    }
    OAuthHmacSigner result = new OAuthHmacSigner();
    result.clientSharedSecret =
        OAUTH_TYPE == OAuthType.UNREGISTERED_HMAC ? "anonymous" : "...";
    if (tokenInfo != null) {
      result.tokenSharedSecret = tokenInfo.tokenSecret;
    }
    return result;
  }

  private static PrivateKey getPrivateKey() throws IOException {
    if (privateKey == null) {
      try {
        privateKey =
            RsaSha.getPrivateKeyFromKeystore(new FileInputStream(
                "WEB-INF/....jks"), "...", "...", "...");
      } catch (GeneralSecurityException e) {
        throw new IOException(e);
      }
    }
    return privateKey;
  }
}
</code></pre>
To later revoke the token:
<pre><code>
    for (Map.Entry&lt;String, TokenInfo&gt; entry : OAUTH_TOKENS.entrySet()) {
      TokenInfo tokenInfo = entry.getValue();
      if (!tokenInfo.temporary) {
        String user = entry.getKey();
        try {
          OAuthParameters parameters = tokenInfo.createParameters();
          GoogleOAuthGetAccessToken.revokeAccessToken(parameters);
        } catch (Exception e) {
          handleException(writer, e);
        }
      }
    }
    OAUTH_TOKENS.clear();
</code></pre>

<p>This package depends on the {@link com.google.api.client.auth.oauth},
{@link com.google.api.client.googleapis}, {@link com.google.api.client.http},
and {@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.auth.storage">
  <!-- start class com.google.api.client.googleapis.auth.storage.GoogleStorageAuthentication -->
  <class name="GoogleStorageAuthentication" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transport" type="com.google.api.client.http.HttpTransport"/>
      <param name="accessKey" type="java.lang.String"/>
      <param name="secret" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@code "Authorization"} header for every executed HTTP request for
 the given HTTP transport.
 <p>
 Any existing HTTP request execute intercepter for Google Storage will be
 removed.
 
 @param transport HTTP transport
 @param accessKey 20 character access key that identifies the client
        accessing the stored data
 @param secret secret associated with the access key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Google Storage for Developers has a custom authentication method described in
 <a href=
 "https://code.google.com/apis/storage/docs/developer-guide.html#authentication"
 >Authentication</a> .
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.auth.storage.GoogleStorageAuthentication -->
  <doc>
  <![CDATA[Google Storage for Developers has a custom authentication method described in
<a
  href="https://code.google.com/apis/storage/docs/developer-guide.html#authentication">Authentication</a>
.

<p>This package depends on {@link com.google.api.client.http} and {@link
com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.json">
  <!-- start class com.google.api.client.googleapis.json.AbstractJsonFeedParser -->
  <class name="AbstractJsonFeedParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parseFeed" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse the feed and return a new parsed instance of the feed class. This
 method can be skipped if all you want are the items.]]>
      </doc>
    </method>
    <method name="parseNextItem" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse the next item in the feed and return a new parsed instanceof of the
 item class. If there is no item to parse, it will return {@code null} and
 automatically close the parser (in which case there is no need to call
 {@link #close()}.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the underlying parser.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract base class for a Google JSON-C feed parser when the feed class is
 known in advance.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.AbstractJsonFeedParser -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument -->
  <class name="DiscoveryDocument" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="load" return="com.google.api.client.googleapis.json.DiscoveryDocument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="apiName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes a request for the JSON-formatted discovery document for the API of
 the given name.

 @param apiName API name
 @return discovery document
 @throws IOException I/O exception executing request]]>
      </doc>
    </method>
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in version 1.2) Use
             {@link GoogleApi#buildRequest(String, Object)}">
      <param name="fullyQualifiedMethodName" type="java.lang.String"/>
      <param name="parameters" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an HTTP request based on the given method name and parameters.

 @param fullyQualifiedMethodName name of method as defined in Discovery
        document of format "resourceName.methodName"
 @param parameters user defined key / value data mapping
 @return HTTP request
 @throws IOException I/O exception reading
 @deprecated (scheduled to be removed in version 1.2) Use
             {@link GoogleApi#buildRequest(String, Object)}]]>
      </doc>
    </method>
    <field name="serviceDefinition" type="com.google.api.client.googleapis.json.DiscoveryDocument.ServiceDefinition"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in version 1.2) Use for example {@code
             get(quote_cHaRbuzzquote_cHaR).get(quote_cHaRv1quote_cHaR)}">
      <doc>
      <![CDATA[First API service definition parsed from discovery document.

 @deprecated (scheduled to be removed in version 1.2) Use for example {@code
             get("buzz").get("v1")}]]>
      </doc>
    </field>
    <field name="apiDefinition" type="com.google.api.client.googleapis.json.DiscoveryDocument.APIDefinition"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Definition of all versions defined in this Google API.

 @since 1.1]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="(scheduled to be removed in version 1.2) Use
             {@link GoogleApi#transport}">
      <doc>
      <![CDATA[Google transport required by {@link #buildRequest}.

 @deprecated (scheduled to be removed in version 1.2) Use
             {@link GoogleApi#transport}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Manages a JSON-formatted document from the experimental Google Discovery API
 version 0.1.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument.APIDefinition -->
  <class name="DiscoveryDocument.APIDefinition" extends="com.google.api.client.util.ArrayMap&lt;java.lang.String, com.google.api.client.googleapis.json.DiscoveryDocument.ServiceDefinition&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscoveryDocument.APIDefinition"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Defines all versions of an API.

 @since 1.1]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument.APIDefinition -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceDefinition -->
  <class name="DiscoveryDocument.ServiceDefinition" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscoveryDocument.ServiceDefinition"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getResourceMethod" return="com.google.api.client.googleapis.json.DiscoveryDocument.ServiceMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodIdentifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns {@link ServiceMethod} definition for given method name. Method
 identifier is of format "resourceName.methodName".]]>
      </doc>
    </method>
    <field name="baseUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Base URL for service endpoint.

 @since 1.1]]>
      </doc>
    </field>
    <field name="resources" type="java.util.Map&lt;java.lang.String, com.google.api.client.googleapis.json.DiscoveryDocument.ServiceResource&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map from the resource name to the resource definition.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines a specific version of an API.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceDefinition -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceMethod -->
  <class name="DiscoveryDocument.ServiceMethod" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscoveryDocument.ServiceMethod"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="pathUrl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Path URL relative to base URL.

 @since 1.1]]>
      </doc>
    </field>
    <field name="httpMethod" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP method name.]]>
      </doc>
    </field>
    <field name="parameters" type="java.util.Map&lt;java.lang.String, com.google.api.client.googleapis.json.DiscoveryDocument.ServiceParameter&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map from parameter name to parameter definition.]]>
      </doc>
    </field>
    <field name="methodType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Method type.

 @since 1.1]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines a method of a service resource.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceMethod -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceParameter -->
  <class name="DiscoveryDocument.ServiceParameter" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscoveryDocument.ServiceParameter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="required" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the parameter is required.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines a parameter to a service method.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceParameter -->
  <!-- start class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceResource -->
  <class name="DiscoveryDocument.ServiceResource" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiscoveryDocument.ServiceResource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="methods" type="java.util.Map&lt;java.lang.String, com.google.api.client.googleapis.json.DiscoveryDocument.ServiceMethod&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map from method name to method definition.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines a resource in a service definition.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.DiscoveryDocument.ServiceResource -->
  <!-- start class com.google.api.client.googleapis.json.GoogleApi -->
  <class name="GoogleApi" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GoogleApi"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Forces the discovery document to be loaded, even if the service definition
 has already been loaded.]]>
      </doc>
    </method>
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fullyQualifiedMethodName" type="java.lang.String"/>
      <param name="parameters" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates an HTTP request based on the given method name and parameters.
 <p>
 If the discovery document has not yet been loaded, it will call
 {@link #load()}.
 </p>

 @param fullyQualifiedMethodName name of method as defined in Discovery
        document of format "resourceName.methodName"
 @param parameters user defined key / value data mapping or {@code null} for
        none
 @return HTTP request
 @throws IOException I/O exception reading]]>
      </doc>
    </method>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(Required) Name of the Google API, for example <code>buzz</code>.]]>
      </doc>
    </field>
    <field name="version" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[(Required) Version of the Google API, for example <code>v1</code>.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport required for building requests in
 {@link #buildRequest(String, Object)}.
 <p>
 It is initialized using {@link GoogleTransport#create()}.]]>
      </doc>
    </field>
    <field name="serviceDefinition" type="com.google.api.client.googleapis.json.DiscoveryDocument.ServiceDefinition"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Service definition, normally set by {@link #load()}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Manages HTTP requests for a version of a Google API service with a simple
 interface based on the new experimental Discovery API.

 @since 1.1
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.GoogleApi -->
  <!-- start class com.google.api.client.googleapis.json.JsonCContent -->
  <class name="JsonCContent" extends="com.google.api.client.json.JsonHttpContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonCContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Serializes JSON-C content based on the data key/value mapping object for an
 item, wrapped in a {@code "data"} envelope.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request, Object data) {
     JsonCContent content = new JsonCContent();
     content.data = data;
     request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.JsonCContent -->
  <!-- start class com.google.api.client.googleapis.json.JsonCParser -->
  <class name="JsonCParser" extends="com.google.api.client.json.JsonHttpParser"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonCParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parserForResponse" return="org.codehaus.jackson.JsonParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a JSON parser to use for parsing the given HTTP response, skipped
 over the {@code "data"} envelope.
 <p>
 The parser will be closed if any throwable is thrown. The current token
 will be the value of the {@code "data"} key.

 @param response HTTP response
 @return JSON parser
 @throws IllegalArgumentException if content type is not
         {@link Json#CONTENT_TYPE} or if {@code "data"} key is not found
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses HTTP JSON-C response content into an data class of key/value pairs,
 assuming the data is wrapped in a {@code "data"} envelope.
 <p>
 Sample usage:

 <pre>
 <code>
 static void setParser(GoogleTransport transport) {
   transport.addParser(new JsonCParser());
 }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.JsonCParser -->
  <!-- start class com.google.api.client.googleapis.json.JsonFeedParser -->
  <class name="JsonFeedParser" extends="com.google.api.client.googleapis.json.AbstractJsonFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonFeedParser" type="JsonParser, java.lang.Class&lt;T&gt;, java.lang.Class&lt;I&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseNextItem" return="I"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="use" return="com.google.api.client.googleapis.json.JsonFeedParser&lt;T, I&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="itemClass" type="java.lang.Class&lt;I&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Google JSON-C feed parser when the item class is known in advance.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.JsonFeedParser -->
  <!-- start class com.google.api.client.googleapis.json.JsonMultiKindFeedParser -->
  <class name="JsonMultiKindFeedParser" extends="com.google.api.client.googleapis.json.AbstractJsonFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonMultiKindFeedParser" type="JsonParser, java.lang.Class&lt;T&gt;, java.lang.Class[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="use" return="com.google.api.client.googleapis.json.JsonMultiKindFeedParser&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="itemClasses" type="java.lang.Class[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Google JSON-C feed parser when the item class can be computed from the kind.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.json.JsonMultiKindFeedParser -->
  <doc>
  <![CDATA[Google's JSON-C as specified in
<a href="http://code.google.com/apis/youtube/2.0/developers_guide_jsonc.html">YouTube
Developer's Guide: JSON-C / JavaScript</a>
(see detailed package specification).

<h2>Package Specification</h2>

<p>User-defined Partial JSON data models allow you to defined Plain Old Java
Objects (POJO's) to define how the library should parse/serialize JSON. Each
field that should be included must have an @{@link
com.google.api.client.util.Key} annotation. The field can be of any visibility
(private, package private, protected, or public) and must not be static. By
default, the field name is used as the JSON key. To override this behavior,
simply specify the JSON key use the optional value parameter of the annotation,
for example {@code @Key("name")}. Any unrecognized keys from the JSON are
normally simply ignored and not stored. If the ability to store unknown keys is
important, use {@link com.google.api.client.json.GenericJson}.</p>

<p>Let's take a look at a typical partial JSON-C video feed from the YouYube
Data API:</p>

<pre><code>
 "data":{
    "updated":"2010-01-07T19:58:42.949Z",
    "totalItems":800,
    "startIndex":1,
    "itemsPerPage":1,
    "items":[
        {"id":"hYB0mn5zh2c",
         "updated":"2010-01-07T13:26:50.000Z",
         "title":"Google Developers Day US - Maps API Introduction",
         "description":"Google Maps API Introduction ...",
         "tags":[
            "GDD07","GDD07US","Maps"
         ],
         "player":{
            "default":"http://www.youtube.com/watch?v\u003dhYB0mn5zh2c"
         },
...
        }
    ]
 }
</code></pre>

<p>Here's one possible way to design the Java data classes for this (each
class in its own Java file):</p>

<pre><code>
import com.google.api.client.util.*;
import java.util.List;

  public class VideoFeed {
    &#64;Key public int itemsPerPage;
    &#64;Key public int startIndex;
    &#64;Key public int totalItems;
    &#64;Key public DateTime updated;
    &#64;Key public List&lt;Video&gt; items;
  }

  public class Video {
    &#64;Key public String id;
    &#64;Key public String title;
    &#64;Key public DateTime updated;
    &#64;Key public String description;
    &#64;Key public List&lt;String&gt; tags;
    &#64;Key public Player player;
  }

  public class Player {
    // "default" is a Java keyword, so need to specify the JSON key manually
    &#64;Key("default")
    public String defaultUrl;
  }
</code></pre>

<p>You can also use the @{@link com.google.api.client.util.Key} annotation
to defined query parameters for a URL. For example:</p>

<pre><code>
public class YouTubeUrl extends GoogleUrl {

  &#64;Key
  public String author;

  &#64;Key("max-results")
  public Integer maxResults;

  public YouTubeUrl(String encodedUrl) {
    super(encodedUrl);
    this.alt = "jsonc";
  }
</code></pre>

<p>To work with the YouTube API, you first need to set up the {@link
com.google.api.client.googleapis.GoogleTransport}. For example:</p>

<pre><code>
  private static GoogleTransport setUpGoogleTransport() throws IOException {
    GoogleTransport transport = new GoogleTransport();
    transport.applicationName = "google-youtubejsoncsample-1.0";
    transport.setVersionHeader(YouTube.VERSION);
    transport.addParser(new JsonParser());
    // insert authentication code...
    return transport;
  }
</code></pre>

<p>Now that we have a transport, we can execute a request to the YouTube API
and parse the result:</p>

<pre><code>
  public static VideoFeed list(GoogleTransport transport, YouTubeUrl url)
      throws IOException {
    HttpRequest request = transport.buildGetRequest();
    request.url = url;
    return request.execute().parseAs(VideoFeed.class);
  }
</code></pre>

<p>If the server responds with an error the {@link
com.google.api.client.http.HttpRequest#execute} method will throw an {@link
com.google.api.client.http.HttpResponseException}, which has an {@link
com.google.api.client.http.HttpResponse} field which can be parsed the same way
as a success response inside of a catch block. For example:</p>

<pre><code>
    try {
...
    } catch (HttpResponseException e) {
      if (e.response.getParser() != null) {
        Error error = e.response.parseAs(Error.class);
        // process error response
      } else {
        String errorContentString = e.response.parseAsString();
        // process error response as string
      }
      throw e;
    }
</code></pre>

<p>NOTE: As you might guess, the library uses reflection to populate the
user-defined data model. It's not quite as fast as writing the wire format
parsing code yourself can potentially be, but it's a lot easier.</p>

<p>NOTE: If you prefer to use your favorite JSON parsing library instead
(there are many of them listed for example on <a href="http://json.org">json.org</a>),
that's supported as well. Just call {@link
com.google.api.client.http.HttpRequest#execute()} and parse the returned byte
stream.</p>

<p>This package depends on the {@link com.google.api.client.http}, {@link
com.google.api.client.json}, {@link com.google.api.client.util}, and {@link
org.codehaus.jackson} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.googleapis.xml.atom">
  <!-- start class com.google.api.client.googleapis.xml.atom.AtomPatchContent -->
  <class name="AtomPatchContent" extends="com.google.api.client.xml.atom.AtomContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomPatchContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Serializes Atom XML PATCH HTTP content based on the data key/value mapping
 object for an Atom entry.
 <p>
 Default value for {@link #contentType} is {@link XmlHttpParser#CONTENT_TYPE}.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request,
     XmlNamespaceDictionary namespaceDictionary, Object entry) {
   AtomPatchContent content = new AtomPatchContent();
   content.namespaceDictionary = namespaceDictionary;
   content.entry = entry;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.xml.atom.AtomPatchContent -->
  <!-- start class com.google.api.client.googleapis.xml.atom.AtomPatchRelativeToOriginalContent -->
  <class name="AtomPatchRelativeToOriginalContent" extends="com.google.api.client.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomPatchRelativeToOriginalContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="patchedEntry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the updated/patched Atom entry.]]>
      </doc>
    </field>
    <field name="originalEntry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the original unmodified Atom entry.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes an optimal Atom XML PATCH HTTP content based on the data key/value
 mapping object for an Atom entry, by comparing the original value to the
 patched value.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request,
     XmlNamespaceDictionary namespaceDictionary, Object originalEntry,
     Object patchedEntry) {
   AtomPatchRelativeToOriginalContent content =
       new AtomPatchRelativeToOriginalContent();
   content.namespaceDictionary = namespaceDictionary;
   content.originalEntry = originalEntry;
   content.patchedEntry = patchedEntry;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.xml.atom.AtomPatchRelativeToOriginalContent -->
  <!-- start class com.google.api.client.googleapis.xml.atom.GData -->
  <class name="GData" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFieldsFor" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the fields mask to use for the given data class of key/value pairs.
 It cannot be a {@link Map}, {@link GenericData} or a {@link Collection}.]]>
      </doc>
    </method>
    <method name="getFeedFields" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feedClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="entryClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the fields mask to use for the given data class of key/value pairs
 for the feed class and for the entry class. This should only be used if the
 feed class does not contain the entry class as a field. The data classes
 cannot be a {@link Map}, {@link GenericData} or a {@link Collection}.]]>
      </doc>
    </method>
    <method name="computePatch" return="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="patched" type="java.lang.Object"/>
      <param name="original" type="java.lang.Object"/>
    </method>
    <method name="computePatchInternal" return="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldsMask" type="com.google.api.client.googleapis.xml.atom.GData.FieldsMask"/>
      <param name="patchedObject" type="java.lang.Object"/>
      <param name="originalObject" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Utilities for working with the Atom XML of Google Data API's.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.xml.atom.GData -->
  <!-- start class com.google.api.client.googleapis.xml.atom.GDataHttp -->
  <class name="GDataHttp" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="GD_NAMESPACE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.xml.atom.GDataHttp -->
  <!-- start class com.google.api.client.googleapis.xml.atom.MultiKindFeedParser -->
  <class name="MultiKindFeedParser" extends="com.google.api.client.xml.atom.AbstractAtomFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MultiKindFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setEntryClasses"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entryClasses" type="java.lang.Class[]"/>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="create" return="com.google.api.client.googleapis.xml.atom.MultiKindFeedParser&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="entryClasses" type="java.lang.Class[]"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[GData Atom feed parser when the entry class can be computed from the kind.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.googleapis.xml.atom.MultiKindFeedParser -->
  <doc>
  <![CDATA[Google's Atom XML implementation (see detailed package specification).

<h2>Package Specification</h2>

<p>User-defined Partial XML data models allow you to defined Plain Old Java
Objects (POJO's) to define how the library should parse/serialize XML. Each
field that should be included must have an @{@link
com.google.api.client.util.Key} annotation. The field can be of any visibility
(private, package private, protected, or public) and must not be static.</p>

<p>The optional value parameter of this @{@link
com.google.api.client.util.Key} annotation specifies the XPath name to use to
represent the field. For example, an XML attribute <code>a</code> has an XPath
name of <code>@a</code>, an XML element <code>&lt;a&gt;</code> has an XPath name
of <code>a</code>, and an XML text content has an XPath name of <code>text()</code>.
These are named based on their usage with the <a
  href="http://code.google.com/apis/gdata/docs/2.0/reference.html#PartialResponse">partial
response/update syntax</a> for Google API's. If the @{@link
com.google.api.client.util.Key} annotation is missing, the default is to use the
Atom XML namespace and the Java field's name as the local XML name. By default,
the field name is used as the JSON key. Any unrecognized XML is normally simply
ignored and not stored. If the ability to store unknown keys is important, use
{@link com.google.api.client.xml.GenericXml}.</p>

<p>Let's take a look at a typical partial Atom XML album feed from the
Picasa Web Albums Data API:</p>

<pre><code>
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;feed xmlns='http://www.w3.org/2005/Atom'
    xmlns:openSearch='http://a9.com/-/spec/opensearch/1.1/'
    xmlns:gphoto='http://schemas.google.com/photos/2007'&gt;
  &lt;link rel='http://schemas.google.com/g/2005#post'
    type='application/atom+xml'
    href='http://picasaweb.google.com/data/feed/api/user/liz' /&gt;
  &lt;author&gt;
    &lt;name&gt;Liz&lt;/name&gt;
  &lt;/author&gt;
  &lt;openSearch:totalResults&gt;1&lt;/openSearch:totalResults&gt;
  &lt;entry gd:etag='"RXY8fjVSLyp7ImA9WxVVGE8KQAE."'&gt;
    &lt;category scheme='http://schemas.google.com/g/2005#kind'
      term='http://schemas.google.com/photos/2007#album' /&gt;
    &lt;title&gt;lolcats&lt;/title&gt;
    &lt;summary&gt;Hilarious Felines&lt;/summary&gt;
    &lt;gphoto:access&gt;public&lt;/gphoto:access&gt;
  &lt;/entry&gt;
&lt;/feed&gt;
</code></pre>

<p>Here's one possible way to design the Java data classes for this (each
class in its own Java file):</p>

<pre><code>
import com.google.api.client.util.*;
import java.util.List;

  public class Link {

    &#64;Key("&#64;href")
    public String href;

    &#64;Key("&#64;rel")
    public String rel;

    public static String find(List&lt;Link&gt; links, String rel) {
      if (links != null) {
        for (Link link : links) {
          if (rel.equals(link.rel)) {
            return link.href;
          }
        }
      }
      return null;
    }
  }

  public class Category {

    &#64;Key("&#64;scheme")
    public String scheme;

    &#64;Key("&#64;term")
    public String term;

    public static Category newKind(String kind) {
      Category category = new Category();
      category.scheme = "http://schemas.google.com/g/2005#kind";
      category.term = "http://schemas.google.com/photos/2007#" + kind;
      return category;
    }
  }

  public class AlbumEntry {

    &#64;Key
    public String summary;

    &#64;Key
    public String title;

    &#64;Key("gphoto:access")
    public String access;

    public Category category = newKind("album");
    
    private String getEditLink() {
      return Link.find(links, "edit");
    }
  }

  public class Author {

    &#64;Key
    public String name;
  }

  public class AlbumFeed {

    &#64;Key
    public Author author;

    &#64;Key("openSearch:totalResults")
    public int totalResults;

    &#64;Key("entry")
    public List&lt;AlbumEntry&gt; photos;

    &#64;Key("link")
    public List&lt;Link&gt; links;

    private String getPostLink() {
      return Link.find(links, "http://schemas.google.com/g/2005#post");
    }
  }
</code></pre>

<p>You can also use the @{@link com.google.api.client.util.Key} annotation
to defined query parameters for a URL. For example:</p>

<pre><code>
public class PicasaUrl extends GoogleUrl {

  &#64;Key("max-results")
  public Integer maxResults;

  &#64;Key
  public String kinds;

  public PicasaUrl(String url) {
    super(url);
  }

  public static PicasaUrl fromRelativePath(String relativePath) {
    PicasaUrl result = new PicasaUrl(PicasaWebAlbums.ROOT_URL);
    result.path += relativePath;
    return result;
  }
}
</code></pre>

<p>To work with a Google API, you first need to set up the {@link
com.google.api.client.googleapis.GoogleTransport}. For example:</p>

<pre><code>
  private static GoogleTransport setUpGoogleTransport() throws IOException {
    GoogleTransport transport = new GoogleTransport();
    transport.applicationName = "google-picasaatomsample-1.0";
    transport.setVersionHeader(PicasaWebAlbums.VERSION);
    AtomParser parser = new AtomParser();
    parser.namespaceDictionary = PicasaWebAlbumsAtom.NAMESPACE_DICTIONARY;
    transport.addParser(parser);
    // insert authentication code...
    return transport;
  }
</code></pre>

<p>Now that we have a transport, we can execute a partial GET request to the
Picasa Web Albums API and parse the result:</p>

<pre><code>
  public static AlbumFeed executeGet(GoogleTransport transport, PicasaUrl url)
      throws IOException {
    url.fields = GData.getFieldsFor(AlbumFeed.class);
    url.kinds = "photo";
    url.maxResults = 5;
    HttpRequest request = transport.buildGetRequest();
    request.url = url;
    return request.execute().parseAs(AlbumFeed.class);
  }
</code></pre>

<p>If the server responds with an error the {@link
com.google.api.client.http.HttpRequest#execute} method will throw an {@link
com.google.api.client.http.HttpResponseException}, which has an {@link
com.google.api.client.http.HttpResponse} field which can be parsed the same way
as a success response inside of a catch block. For example:</p>

<pre><code>
    try {
...
    } catch (HttpResponseException e) {
      if (e.response.getParser() != null) {
        Error error = e.response.parseAs(Error.class);
        // process error response
      } else {
        String errorContentString = e.response.parseAsString();
        // process error response as string
      }
      throw e;
    }
</code></pre>

<p>To update an album, we use the transport to execute an efficient partial
update request using the PATCH method to the Picasa Web Albums API:</p>

<pre><code>
  public AlbumEntry executePatchRelativeToOriginal(GoogleTransport transport,
      AlbumEntry original) throws IOException {
    HttpRequest request = transport.buildPatchRequest();
    request.setUrl(getEditLink());
    request.headers.ifMatch = etag;
    PatchRelativeToOriginalContent content =
        new PatchRelativeToOriginalContent();
    content.namespaceDictionary = PicasaWebAlbumsAtom.NAMESPACE_DICTIONARY;
    content.originalEntry = original;
    content.patchedEntry = this;
    request.content = content;
    return request.execute().parseAs(AlbumEntry.class);
  }

  private static AlbumEntry updateTitle(GoogleTransport transport,
      AlbumEntry album) throws IOException {
    AlbumEntry patched = album.clone();
    patched.title = "An alternate title";
    return patched.executePatchRelativeToOriginal(transport, album);
  }
</code></pre>

<p>To insert an album, we use the transport to execute a POST request to the
Picasa Web Albums API:</p>

<pre><code>
  public AlbumEntry insertAlbum(GoogleTransport transport, AlbumEntry entry)
      throws IOException {
    HttpRequest request = transport.buildPostRequest();
    request.setUrl(getPostLink());
    AtomContent content = new AtomContent();
    content.namespaceDictionary = PicasaWebAlbumsAtom.NAMESPACE_DICTIONARY;
    content.entry = entry;
    request.content = content;
    return request.execute().parseAs(AlbumEntry.class);
  }
</code></pre>

<p>To delete an album, we use the transport to execute a DELETE request to
the Picasa Web Albums API:</p>

<pre><code>
  public void executeDelete(GoogleTransport transport) throws IOException {
    HttpRequest request = transport.buildDeleteRequest();
    request.setUrl(getEditLink());
    request.headers.ifMatch = etag;
    request.execute().ignore();
  }
</code></pre>

<p>NOTE: As you might guess, the library uses reflection to populate the
user-defined data model. It's not quite as fast as writing the wire format
parsing code yourself can potentially be, but it's a lot easier.</p>

<p>NOTE: If you prefer to use your favorite XML parsing library instead
(there are many of them), that's supported as well. Just call {@link
com.google.api.client.http.HttpRequest#execute()} and parse the returned byte
stream.</p>

<p>This package depends on the {@link com.google.api.client.http}, {@link
com.google.api.client.util}, {@link com.google.api.client.xml}, {@link
com.google.api.client.xml.atom}, and {@code org.xmlpull.v1} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.http">
  <!-- start class com.google.api.client.http.GenericUrl -->
  <class name="GenericUrl" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericUrl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GenericUrl" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs from an encoded URL.
 <p>
 Any known query parameters with pre-defined fields as data keys will be
 parsed based on their data type. Any unrecognized query parameter will
 always be parsed as a string.

 @param encodedUrl encoded URL, including any existing query parameters that
        should be parsed
 @throws IllegalArgumentException if URL has a syntax error]]>
      </doc>
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.http.GenericUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs the string representation of the URL, including the path
 specified by {@link #pathParts} and the query parameters specified by this
 generic URL.]]>
      </doc>
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the first query parameter value for the given query parameter name.

 @param name query parameter name
 @return first query parameter value]]>
      </doc>
    </method>
    <method name="getAll" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all query parameter values for the given query parameter name.

 @param name query parameter name
 @return unmodifiable collection of query parameter values (possibly empty)]]>
      </doc>
    </method>
    <method name="getRawPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw encoded path computed from the {@link #pathParts}.

 @return raw encoded path computed from the {@link #pathParts} or {@code
         null} if {@link #pathParts} is {@code null}]]>
      </doc>
    </method>
    <method name="setRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #pathParts} from the given raw encoded path.

 @param encodedPath raw encoded path or {@code null} to set
        {@link #pathParts} to {@code null}]]>
      </doc>
    </method>
    <method name="appendRawPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Appends the given raw encoded path to the current {@link #pathParts},
 setting field only if it is {@code null} or empty.
 <p>
 The last part of the {@link #pathParts} is merged with the first part of
 the path parts computed from the given encoded path. Thus, if the current
 raw encoded path is {@code "a"}, and the given encoded path is {@code "b"},
 then the resulting raw encoded path is {@code "ab"}.

 @param encodedPath raw encoded path or {@code null} to ignore]]>
      </doc>
    </method>
    <method name="toPathParts" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the decoded path parts for the given encoded path.

 @param encodedPath slash-prefixed encoded path, for example {@code
        "/m8/feeds/contacts/default/full"}
 @return decoded path parts, with each part assumed to be preceded by a
         {@code '/'}, for example {@code "", "m8", "feeds", "contacts",
         "default", "full"}, or {@code null} for {@code null} or {@code ""}
         input]]>
      </doc>
    </method>
    <field name="scheme" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Scheme (lowercase), for example {@code "https"}.]]>
      </doc>
    </field>
    <field name="host" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Host, for example {@code "www.google.com"}.]]>
      </doc>
    </field>
    <field name="port" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Port number or {@code -1} if undefined, for example {@code 443}.]]>
      </doc>
    </field>
    <field name="pathParts" type="java.util.List&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decoded path component by parts with each part separated by a {@code '/'}
 or {@code null} for none, for example {@code
 "/m8/feeds/contacts/default/full"} is represented by {@code "", "m8",
 "feeds", "contacts", "default", "full"}.
 <p>
 Use {@link #appendRawPath(String)} to append to the path, which ensures
 that no extra slash is added.]]>
      </doc>
    </field>
    <field name="fragment" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Fragment component or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[URL builder in which the query parameters are specified as generic data
 key/value pairs, based on the specification <a
 href="http://tools.ietf.org/html/rfc3986">RFC 3986: Uniform Resource
 Identifier (URI)</a>.
 <p>
 The query parameters are specified with the data key name as the parameter
 name, and the data value as the parameter value. Subclasses can declare
 fields for known query parameters using the {@link Key} annotation. {@code
 null} parameter names are not allowed, but {@code null} query values are
 allowed.
 </p>
 <p>
 Query parameter values are parsed using
 {@link UrlEncodedParser#parse(String, Object)}.
 </p>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.GenericUrl -->
  <!-- start interface com.google.api.client.http.HttpContent -->
  <interface name="HttpContent"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content length or less than zero if not known.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null}
 for none.]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content to the given output stream.
 
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Serializes HTTP request content into an output stream.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpContent -->
  <!-- start interface com.google.api.client.http.HttpExecuteIntercepter -->
  <interface name="HttpExecuteIntercepter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="intercept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Invoked at the start of {@link HttpRequest#execute()}.
 
 @throws IOException any I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[HTTP request execute intercepter invoked at the start of
 {@link HttpRequest#execute()}.
 <p>
 Useful for example for signing HTTP requests during authentication. Care
 should be taken to ensure that intercepters not interfere with each other
 since there are no guarantees regarding their independence. In particular,
 the order in which the intercepters are invoked is important.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpExecuteIntercepter -->
  <!-- start class com.google.api.client.http.HttpHeaders -->
  <class name="HttpHeaders" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpHeaders"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.http.HttpHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="canonicalMap" return="java.util.Map&lt;java.lang.String, java.util.Collection&lt;java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Computes a canonical map from lower-case header name to its values.

 @return canonical map from lower-case header name to its values]]>
      </doc>
    </method>
    <field name="accept" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Accept"} header.]]>
      </doc>
    </field>
    <field name="acceptEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Accept-Encoding"} header. By default, this is {@code "gzip"}.]]>
      </doc>
    </field>
    <field name="authorization" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Authorization"} header.]]>
      </doc>
    </field>
    <field name="cacheControl" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Cache-Control"} header.]]>
      </doc>
    </field>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Encoding"} header.]]>
      </doc>
    </field>
    <field name="contentLength" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Length"} header.]]>
      </doc>
    </field>
    <field name="contentMD5" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-MD5"} header.]]>
      </doc>
    </field>
    <field name="contentRange" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Range"} header.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Content-Type"} header.]]>
      </doc>
    </field>
    <field name="date" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Date"} header.]]>
      </doc>
    </field>
    <field name="etag" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "ETag"} header.]]>
      </doc>
    </field>
    <field name="expires" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Expires"} header.]]>
      </doc>
    </field>
    <field name="ifModifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Modified-Since"} header.]]>
      </doc>
    </field>
    <field name="ifMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Match"} header.]]>
      </doc>
    </field>
    <field name="ifNoneMatch" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-None-Match"} header.]]>
      </doc>
    </field>
    <field name="ifUnmodifiedSince" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "If-Unmodified-Since"} header.]]>
      </doc>
    </field>
    <field name="lastModified" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Last-Modified"} header.]]>
      </doc>
    </field>
    <field name="location" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Location"} header.]]>
      </doc>
    </field>
    <field name="mimeVersion" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "MIME-Version"} header.]]>
      </doc>
    </field>
    <field name="range" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Range"} header.]]>
      </doc>
    </field>
    <field name="retryAfter" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "Retry-After"} header.]]>
      </doc>
    </field>
    <field name="userAgent" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "User-Agent"} header.]]>
      </doc>
    </field>
    <field name="authenticate" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "WWW-Authenticate"} header.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Stores HTTP headers used in an HTTP request or response, as defined in <a
 href="http://tools.ietf.org/html/rfc2616#section-14">Header Field
 Definitions</a>.
 <p>
 {@code null} is not allowed as a name or value of a header. Names are
 case-insensitive.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpHeaders -->
  <!-- start interface com.google.api.client.http.HttpParser -->
  <interface name="HttpParser"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type.]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the given HTTP response into a new instance of the the given data
 class of key/value pairs.
 <p>
 How the parsing is performed is not restricted by this interface, and is
 instead defined by the concrete implementation. Implementations should
 check {@link HttpResponse#isSuccessStatusCode} to know whether they are
 parsing a success or error response.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parses HTTP response content into an data class of key/value pairs.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.http.HttpParser -->
  <!-- start class com.google.api.client.http.HttpRequest -->
  <class name="HttpRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="setUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encodedUrl" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the {@link #url} based on the given encoded URL string.]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.HttpResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the HTTP request and returns the HTTP response.
 <p>
 Note that regardless of the returned status code, the HTTP response content
 has not been parsed yet, and must be parsed by the calling code.
 <p>
 Almost all details of the request and response are logged if
 {@link Level#CONFIG} is loggable. The only exception is the value of the
 {@code Authorization} header which is only logged if {@link Level#ALL} is
 loggable.

 @return HTTP response for an HTTP success code
 @throws HttpResponseException for an HTTP error code
 @see HttpResponse#isSuccessStatusCode]]>
      </doc>
    </method>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request headers.
 <p>
 Its value is initialized by calling {@code clone()} on the
 {@link HttpTransport#defaultHeaders}. Therefore, it is initialized to be of
 the same Java class, i.e. of the same {@link Object#getClass()}.]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable request content logging during {@link #execute()}
 (unless {@link Level#ALL} is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication
 information. Defaults to {@code false}.]]>
      </doc>
    </field>
    <field name="content" type="com.google.api.client.http.HttpContent"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request content or {@code null} for none.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport.]]>
      </doc>
    </field>
    <field name="method" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request method.]]>
      </doc>
    </field>
    <field name="url" type="com.google.api.client.http.GenericUrl"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request URL.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP request.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpRequest -->
  <!-- start class com.google.api.client.http.HttpResponse -->
  <class name="HttpResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getContent" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the content of the HTTP response.
 <p>
 The result is cached, so subsequent calls will be fast.

 @return input stream content of the HTTP response or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="ignore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the content of the HTTP response from {@link #getContent()} and
 ignores the content if there is any.

 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the content type of
 this HTTP response or {@code null} for none.]]>
      </doc>
    </method>
    <method name="parseAs" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and
 reads it into a data class of key/value pairs using the parser returned by
 {@link #getParser()} .

 @return parsed data class or {@code null} for no content
 @throws IOException I/O exception
 @throws IllegalArgumentException if no parser is defined for the given
         content type or if there is no content type defined in the HTTP
         response]]>
      </doc>
    </method>
    <method name="parseAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parses the content of the HTTP response from {@link #getContent()} and
 reads it into a string.
 <p>
 Since this method returns {@code ""} for no content, a simpler check for no
 content is to check if {@link #getContent()} is {@code null}.

 @return parsed string or {@code ""} for no content
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="isSuccessStatusCode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statusCode" type="int"/>
      <doc>
      <![CDATA[Returns whether the given HTTP response status code is a success code
 {@code >= 200 and < 300}.]]>
      </doc>
    </method>
    <field name="contentEncoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content encoding or {@code null}.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type or {@code null} for none.]]>
      </doc>
    </field>
    <field name="headers" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP headers.
 <p>
 If a header name is used for multiple headers, only the last one is
 retained.
 <p>
 This field's value is instantiated using the same class as that of the
 {@link HttpTransport#defaultHeaders}.]]>
      </doc>
    </field>
    <field name="isSuccessStatusCode" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether received a successful status code {@code >= 200 && < 300}.]]>
      </doc>
    </field>
    <field name="statusCode" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Status code.]]>
      </doc>
    </field>
    <field name="statusMessage" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Status message or {@code null}.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport.]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable response content logging during {@link #getContent()}
 (unless {@link Level#ALL} is loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication
 token. Defaults to {@code false}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP response.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponse -->
  <!-- start class com.google.api.client.http.HttpResponseException -->
  <class name="HttpResponseException" extends="java.io.IOException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpResponseException" type="com.google.api.client.http.HttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param response HTTP response]]>
      </doc>
    </constructor>
    <method name="computeMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <doc>
      <![CDATA[Returns an exception message to use for the given HTTP response.]]>
      </doc>
    </method>
    <field name="response" type="com.google.api.client.http.HttpResponse"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP response.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Exception thrown when an error status code is detected in an HTTP response.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpResponseException -->
  <!-- start class com.google.api.client.http.HttpTransport -->
  <class name="HttpTransport" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setLowLevelHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lowLevelHttpTransport" type="com.google.api.client.http.LowLevelHttpTransport"/>
      <doc>
      <![CDATA[Sets to the given low level HTTP transport.
 <p>
 Must be set before the first HTTP transport is constructed or else the
 default will be used as specified in {@link #useLowLevelHttpTransport()}.

 @param lowLevelHttpTransport low level HTTP transport or {@code null} to
        use the default of {@code java.net} transport]]>
      </doc>
    </method>
    <method name="useLowLevelHttpTransport" return="com.google.api.client.http.LowLevelHttpTransport"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the low-level HTTP transport to use. If
 {@link #setLowLevelHttpTransport(LowLevelHttpTransport)} hasn't been
 called, it uses the default of {@code java.net} transport.]]>
      </doc>
    </method>
    <method name="addParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="com.google.api.client.http.HttpParser"/>
      <doc>
      <![CDATA[Adds an HTTP response content parser.
 <p>
 If there is already a previous parser defined for this new parser (as
 defined by {@link #getParser(String)} then the previous parser will be
 removed.]]>
      </doc>
    </method>
    <method name="getParser" return="com.google.api.client.http.HttpParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the HTTP response content parser to use for the given content type
 or {@code null} if none is defined.

 @param contentType content type or {@code null} for {@code null} result]]>
      </doc>
    </method>
    <method name="buildRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a request without specifying the HTTP method.]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code DELETE} request.]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code GET} request.]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code POST} request.]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code PUT} request.]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code PATCH} request.]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a {@code HEAD} request.]]>
      </doc>
    </method>
    <method name="removeIntercepters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="intercepterClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Removes HTTP request execute intercepters of the given class or subclasses.

 @param intercepterClass intercepter class]]>
      </doc>
    </method>
    <field name="defaultHeaders" type="com.google.api.client.http.HttpHeaders"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default HTTP headers. These transport default headers are put into a
 request's headers when its build method is called.]]>
      </doc>
    </field>
    <field name="intercepters" type="java.util.List&lt;com.google.api.client.http.HttpExecuteIntercepter&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP request execute intercepters. The intercepters will be invoked in the
 order of the {@link List#iterator()}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP transport.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.HttpTransport -->
  <!-- start class com.google.api.client.http.InputStreamContent -->
  <class name="InputStreamContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="InputStreamContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setFileInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Sets the {@link #inputStream} from a file input stream based on the given
 file, and the {@link #length} based on the file's length.
 <p>
 Sample use:

 <pre>
 <code>
 private static void setRequestJpegContent(HttpRequest request, File jpegFile) {
   InputStreamContent content = new InputStreamContent();
   content.setFileInput(jpegFile);
   content.type = "image/jpeg";
   request.content = content;
 }
 </code>
 </pre>]]>
      </doc>
    </method>
    <method name="setByteArrayInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="byte[]"/>
      <doc>
      <![CDATA[Sets the {@link #inputStream} and {@link #length} from the given byte
 array.
 <p>
 For string input, call the appropriate {@link String#getBytes} method.
 <p>
 Sample use:

 <pre>
 <code>
 private static void setRequestJsonContent(HttpRequest request, String json) {
   InputStreamContent content = new InputStreamContent();
   content.setByteArrayInput(json.getBytes());
   content.type = "application/json";
   request.content = content;
 }
 </code>
 </pre>]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="outputStream" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the content provided by the given source input stream into the given
 destination output stream.
 <p>
 The input stream is guaranteed to be closed at the end of the method.
 </p>
 <p>
 Sample use:

 <pre><code>
  static void downloadMedia(HttpResponse response, File file)
      throws IOException {
    FileOutputStream out = new FileOutputStream(file);
    try {
      InputStreamContent.copy(response.getContent(), out);
    } finally {
      out.close();
    }
  }
 </code></pre>
 </p>

 @param inputStream source input stream
 @param outputStream destination output stream
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="type" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required content type.]]>
      </doc>
    </field>
    <field name="length" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content length or less than zero if not known. Defaults to {@code -1}.]]>
      </doc>
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Required input stream to read from.]]>
      </doc>
    </field>
    <field name="encoding" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content encoding (for example {@code "gzip"}) or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes HTTP request content from an input stream into an output stream.
 <p>
 The {@link #type} and {@link #inputStream} fields are required. The input
 stream is guaranteed to be closed at the end of
 {@link #writeTo(OutputStream)}.
 <p>
 For a file input, use {@link #setFileInput(File)}, and for a byte array or
 string input use {@link #setByteArrayInput(byte[])}.
 <p>
 Sample use with a URL:

 <pre>
 <code>
 private static void setRequestJpegContent(HttpRequest request, URL jpegUrl) {
   InputStreamContent content = new InputStreamContent();
   content.inputStream = jpegUrl.openStream();
   content.type = "image/jpeg";
   request.content = content;
 }
 </code>
 </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.InputStreamContent -->
  <!-- start class com.google.api.client.http.LowLevelHttpRequest -->
  <class name="LowLevelHttpRequest" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addHeader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a header to the HTTP request.
 <p>
 Note that multiple headers of the same name need to be supported, in which
 case {@link #addHeader} will be called for each instance of the header.
 
 @param name header name
 @param value header value]]>
      </doc>
    </method>
    <method name="setContent"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="com.google.api.client.http.HttpContent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the HTTP request content.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="execute" return="com.google.api.client.http.LowLevelHttpResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Executes the request and returns a low-level HTTP response object.
 
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP request.
 <p>
 This allows providing a different implementation of the HTTP request that is
 more compatible with the Java environment used.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpRequest -->
  <!-- start class com.google.api.client.http.LowLevelHttpResponse -->
  <class name="LowLevelHttpResponse" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpResponse"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContent" return="java.io.InputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the HTTP response content input stream or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getContentEncoding" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content encoding (for example {@code "gzip"}) or {@code null}
 for none.]]>
      </doc>
    </method>
    <method name="getContentLength" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content length or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getContentType" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the content type or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusLine" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status line or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getStatusCode" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the response status code or {@code 0} for none.]]>
      </doc>
    </method>
    <method name="getReasonPhrase" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the HTTP reason phrase or {@code null} for none.]]>
      </doc>
    </method>
    <method name="getHeaderCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of HTTP response headers.
 <p>
 Note that multiple headers of the same name need to be supported, in which
 case each header value is treated as a separate header.]]>
      </doc>
    </method>
    <method name="getHeaderName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header name at the given zero-based index.]]>
      </doc>
    </method>
    <method name="getHeaderValue" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the HTTP response header value at the given zero-based index.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP response.
 <p>
 This allows providing a different implementation of the HTTP response that is
 more compatible with the Java environment used.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpResponse -->
  <!-- start class com.google.api.client.http.LowLevelHttpTransport -->
  <class name="LowLevelHttpTransport" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LowLevelHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code
 HEAD} request method.
 <p>
 Default implementation returns {@code false}.]]>
      </doc>
    </method>
    <method name="supportsPatch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether this HTTP transport implementation supports the {@code
 PATCH} request method.
 <p>
 Default implementation returns {@code false}.]]>
      </doc>
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code DELETE} request.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code GET} request.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code HEAD} request. Won't be called if {@link #supportsHead()}
 returns {@code false}.
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="buildPatchRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PATCH} request. Won't be called if {@link #supportsPatch()}
 returns {@code false}.
 <p>
 Default implementation throws an {@link UnsupportedOperationException}.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code POST} request.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.http.LowLevelHttpRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a {@code PUT} request.
 
 @param url URL
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Low-level HTTP transport.
 <p>
 This allows providing a different implementation of the HTTP transport that
 is more compatible with the Java environment used.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.LowLevelHttpTransport -->
  <!-- start class com.google.api.client.http.MultipartContent -->
  <class name="MultipartContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="(scheduled to be removed in version 1.2) Use
             {@link MultipartRelatedContent}">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="MultipartContent" type="com.google.api.client.http.HttpContent, com.google.api.client.http.HttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="forRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Multi-part related content.

 @since 1.0
 @author Yaniv Inbar
 @deprecated (scheduled to be removed in version 1.2) Use
             {@link MultipartRelatedContent}]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.MultipartContent -->
  <!-- start class com.google.api.client.http.MultipartRelatedContent -->
  <class name="MultipartRelatedContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="MultipartRelatedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="forRequest" return="com.google.api.client.http.MultipartRelatedContent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.http.HttpRequest"/>
      <doc>
      <![CDATA[Returns a new multi-part content serializer as the content for the given
 HTTP request.

 <p>
 It also sets the {@link HttpHeaders#mimeVersion} of
 {@link HttpRequest#headers headers} to {@code "1.0"}.
 </p>

 @param request HTTP request
 @return new multi-part content serializer]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="boundary" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Boundary string to use. By default, it is {@code "END_OF_PART"}.]]>
      </doc>
    </field>
    <field name="parts" type="java.util.Collection&lt;com.google.api.client.http.HttpContent&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Collection of HTTP content parts. By default, it is an empty list.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes MIME Multipart/Related content as specified by <a
 href="http://tools.ietf.org/html/rfc2387">RFC 2387: The MIME
 Multipart/Related Content-type</a>.
 <p>
 Limitations:
 <ul>
 <li>No support of parameters other than {@code "boundary"}</li>
 <li>No support for specifying headers for each content part</li>
 </ul>
 </p>
 <p>
 Sample usage:

 <pre><code>
  static void setMediaWithMetadataContent(HttpRequest request,
      AtomContent atomContent, InputStreamContent imageContent) {
    MultipartRelatedContent content =
        MultipartRelatedContent.forRequest(request);
    content.parts.add(atomContent);
    content.parts.add(imageContent);
  }
 </code></pre>

 @since 1.1
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.MultipartRelatedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedContent -->
  <class name="UrlEncodedContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="UrlEncodedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link UrlEncodedParser#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value data or {@code null} for none.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding serialization of type
 {@code application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4.1">HTML 4.0
 Specification</a>.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request, Object item) {
   UrlEncodedContent content = new UrlEncodedContent();
   content.setData(item);
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedContent -->
  <!-- start class com.google.api.client.http.UrlEncodedParser -->
  <class name="UrlEncodedParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="UrlEncodedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="content" type="java.lang.String"/>
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Parses the given URL-encoded content into the given data object of data key
 name/value pairs, including support for repeating data key names.
 <p>
 Declared fields of a "primitive" type (as defined by
 {@link FieldInfo#isPrimitive(Class)} are parsed using
 {@link FieldInfo#parsePrimitiveValue(Class, String)} where the
 {@link Class} parameter is the declared field class. Declared fields of
 type {@link Collection} are used to support repeating data key names, so
 each member of the collection is an additional data key value. They are
 parsed the same as "primitive" fields, except that the generic type
 parameter of the collection is used as the {@link Class} parameter. For
 keys not represented by a declared field, the field type is assumed to be
 {@link ArrayList}&lt;String&gt;.
 
 @param content URL-encoded content
 @param data data key name/value pairs]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/x-www-form-urlencoded"} content type.]]>
      </doc>
    </field>
    <field name="disableContentLogging" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether to disable response content logging (unless {@link Level#ALL} is
 loggable which forces all logging).
 <p>
 Useful for example if content has sensitive data such as an authentication
 token. Defaults to {@code false}.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Implements support for HTTP form content encoding parsing of type {@code
 application/x-www-form-urlencoded} as specified in the <a href=
 "http://www.w3.org/TR/1998/REC-html40-19980424/interact/forms.html#h-17.13.4.1"
 >HTML 4.0 Specification</a>.
 <p>
 The data is parsed using {@link #parse(String, Object)}.
 </p>
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setParser(HttpTransport transport) {
   transport.addParser(new UrlEncodedParser());
 }
 </code>
 </pre>
 
 </p>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.http.UrlEncodedParser -->
  <doc>
  <![CDATA[Subset of HTTP 1.1 needed from the specification in
<a href="http://tools.ietf.org/html/rfc2616">RFC 2616: Hypertext Transfer
Protocol -- HTTP/1.1</a>
. Additionally, it includes
<a href="http://tools.ietf.org/html/rfc5789">PATCH Method for HTTP</a>
.

<p>This package depends on the {@link com.google.api.client.auth}, {@link
com.google.api.client.escape}, and {@link com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.javanet">
  <!-- start class com.google.api.client.javanet.NetHttpTransport -->
  <class name="NetHttpTransport" extends="com.google.api.client.http.LowLevelHttpTransport"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="supportsHead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildDeleteRequest" return="com.google.api.client.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildHeadRequest" return="com.google.api.client.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="buildPutRequest" return="com.google.api.client.javanet.NetHttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="com.google.api.client.javanet.NetHttpTransport"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Singleton instance of this transport.]]>
      </doc>
    </field>
    <field name="connectTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the connection timeout to a specified timeout in milliseconds by
 calling {@link HttpURLConnection#setConnectTimeout(int)}, or a negative
 value avoid calling that method. By default it is 20 seconds.

 @since 1.1]]>
      </doc>
    </field>
    <field name="readTimeout" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the read timeout to a specified timeout in milliseconds by calling
 {@link HttpURLConnection#setReadTimeout(int)}, or a negative value avoid
 calling that method. By default it is 20 seconds.

 @since 1.1]]>
      </doc>
    </field>
    <doc>
    <![CDATA[HTTP low-level transport based on the {@code java.net} package.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.javanet.NetHttpTransport -->
  <doc>
  <![CDATA[HTTP Transport library for Google API's based on the {@code java.net} package.

<p>This package depends on the {@link com.google.api.client.http} package.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.json">
  <!-- start class com.google.api.client.json.CustomizeJsonParser -->
  <class name="CustomizeJsonParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CustomizeJsonParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopAt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing at the given key of the given context
 object.]]>
      </doc>
    </method>
    <method name="handleUnrecognizedKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Called when the given unrecognized key is encountered in the given context
 object.]]>
      </doc>
    </method>
    <method name="newInstanceForArray" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field in the given context
 object for a JSON array or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <method name="newInstanceForObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="java.lang.Object"/>
      <param name="fieldClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance value for the given field class in the given context
 object for JSON Object or {@code null} for the default behavior.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of a JSON parser.
 <p>
 All methods have a default trivial implementation, so subclasses need only
 implement the methods whose behavior needs customization.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.CustomizeJsonParser -->
  <!-- start class com.google.api.client.json.GenericJson -->
  <class name="GenericJson" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericJson"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.json.GenericJson"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Generic JSON data that stores all unknown key name/value pairs.
 <p>
 Subclasses can declare fields for known data keys using the {@link Key}
 annotation. Each field can be of any visibility (private, package private,
 protected, or public) and must not be static. {@code null} unknown data key
 names are not allowed, but {@code null} data values are allowed.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.GenericJson -->
  <!-- start class com.google.api.client.json.Json -->
  <class name="Json" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Json"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="item" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a debug JSON string representation for the given item intended for
 use in {@link Object#toString()}.
 
 @param item data key/value pairs
 @return debug JSON string representation]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="generator" type="JsonGenerator"/>
      <param name="value" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes the given JSON value object using the given JSON generator.]]>
      </doc>
    </method>
    <method name="parseAndClose" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser (which is closed after
 parsing completes) into the given destination class, optionally using the
 given parser customizer.
 
 @param <T> destination class type
 @param parser JSON parser
 @param destinationClass destination class that has a public default
        constructor to use to create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="skipToKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="keyToFind" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips the values of all keys in the current object until it finds the given
 key.
 <p>
 The current token will either be the {@link JsonToken#END_OBJECT} of the
 current object if the key is not found, or the value of the key that was
 found.
 
 @param parser JSON parser
 @param keyToFind key to find
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parseAndClose"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser (which is closed after
 parsing completes) into the given destination object, optionally using the
 given parser customizer.
 
 @param parser JSON parser
 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser into the given destination
 class, optionally using the given parser customizer.
 
 @param <T> destination class type
 @param parser JSON parser
 @param destinationClass destination class that has a public default
        constructor to use to create a new instance
 @param customizeParser optional parser customizer or {@code null} for none
 @return new instance of the parsed destination class
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destination" type="java.lang.Object"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Object from the given JSON parser into the given destination
 object, optionally using the given parser customizer.
 
 @param parser JSON parser
 @param destination destination object
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parseArrayAndClose" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after
 parsing completes) into the given destination collection, optionally using
 the given parser customizer.
 
 @param parser JSON parser
 @param destinationCollectionClass class of destination collection (must
        have a public default constructor)
 @param destinationItemClass class of destination collection item (must have
        a public default constructor)
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parseArrayAndClose"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser (which is closed after
 parsing completes) into the given destination collection, optionally using
 the given parser customizer.
 
 @param parser JSON parser
 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have
        a public default constructor)
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parseArray" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationCollectionClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination
 collection, optionally using the given parser customizer.
 
 @param parser JSON parser
 @param destinationCollectionClass class of destination collection (must
        have a public default constructor)
 @param destinationItemClass class of destination collection item (must have
        a public default constructor)
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="parseArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="JsonParser"/>
      <param name="destinationCollection" type="java.util.Collection&lt;? super T&gt;"/>
      <param name="destinationItemClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="customizeParser" type="com.google.api.client.json.CustomizeJsonParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse a JSON Array from the given JSON parser into the given destination
 collection, optionally using the given parser customizer.
 
 @param parser JSON parser
 @param destinationCollection destination collection
 @param destinationItemClass class of destination collection item (must have
        a public default constructor)
 @param customizeParser optional parser customizer or {@code null} for none
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="JSON_FACTORY" type="JsonFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[JSON factory.]]>
      </doc>
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/json"} content type.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON utilities.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.Json -->
  <!-- start class com.google.api.client.json.JsonHttpContent -->
  <class name="JsonHttpContent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="JsonHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link Json#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes JSON HTTP content based on the data key/value mapping object for
 an item.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request, Object data) {
   JsonHttpContent content = new JsonHttpContent();
   content.data = data;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonHttpContent -->
  <!-- start class com.google.api.client.json.JsonHttpParser -->
  <class name="JsonHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="JsonHttpParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parserForResponse" return="JsonParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a JSON parser to use for parsing the given HTTP response.
 <p>
 The response content will be closed if any throwable is thrown. On success,
 the current token will be the first key in the JSON object.
 
 @param response HTTP response
 @return JSON parser
 @throws IllegalArgumentException if content type is not
         {@link Json#CONTENT_TYPE}
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type.  Default value is {@link Json#CONTENT_TYPE}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses HTTP JSON response content into an data class of key/value pairs.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setParser(HttpTransport transport) {
   transport.addParser(new JsonHttpParser());
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.JsonHttpParser -->
  <doc>
  <![CDATA[JSON as specified in
<a href="http://tools.ietf.org/html/rfc4627">RFC 4627: The application/json
Media Type for JavaScript Object Notation (JSON)</a>
and
<a href="http://json.org/">Introducing JSON</a>
.

<p>This package depends on the {@link com.google.api.client.util} and {@link
org.codehaus.jackson} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.json.rpc2">
  <!-- start class com.google.api.client.json.rpc2.JsonRpcHttpTransport -->
  <class name="JsonRpcHttpTransport" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonRpcHttpTransport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.json.rpc2.JsonRpcRequest"/>
      <doc>
      <![CDATA[Builds a POST HTTP request for the JSON-RPC requests objects specified in
 the given JSON-RPC request object.
 <p>
 You may use {@link JsonHttpParser#parserForResponse(HttpResponse)
 JsonHttpParser.parserForResponse}({@link #buildPostRequest(JsonRpcRequest)
 execute} (request)) to get the {@link JsonParser}, and
 {@link Json#parseAndClose(JsonParser, Class, CustomizeJsonParser)} .
 </p>

 @param request JSON-RPC request object
 @return HTTP request]]>
      </doc>
    </method>
    <method name="buildPostRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requests" type="java.util.List&lt;com.google.api.client.json.rpc2.JsonRpcRequest&gt;"/>
      <doc>
      <![CDATA[Builds a POST HTTP request for the JSON-RPC requests objects specified in
 the given JSON-RPC request objects.
 <p>
 Note that the request will always use batching -- i.e. JSON array of
 requests -- even if there is only one request. You may use
 {@link JsonHttpParser#parserForResponse(HttpResponse)
 JsonHttpParser.parserForResponse}({@link #buildPostRequest(List) execute}
 (requests)) to get the {@link JsonParser}, and {@link
 Json#parseArrayAndClose(JsonParser, Collection, Class,
 CustomizeJsonParser)} .
 </p>

 @param requests JSON-RPC request objects
 @return HTTP request]]>
      </doc>
    </method>
    <method name="buildGetRequest" return="com.google.api.client.http.HttpRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.api.client.json.rpc2.JsonRpcRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Builds a GET HTTP request for the JSON-RPC requests objects specified in
 the given JSON-RPC request object.
 <p>
 You may use {@link JsonHttpParser#parserForResponse(HttpResponse)
 JsonHttpParser.parserForResponse}( {@link #buildGetRequest(JsonRpcRequest)
 executeUsingGet} (request)) to get the {@link JsonParser}, and
 {@link Json#parseAndClose(JsonParser, Class, CustomizeJsonParser)} .
 </p>

 @param request JSON-RPC request object
 @return HTTP response
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="rpcServerUrl" type="com.google.api.client.http.GenericUrl"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[RPC server URL.]]>
      </doc>
    </field>
    <field name="transport" type="com.google.api.client.http.HttpTransport"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP transport to use for executing HTTP requests. By default this is an
 unmodified new instance of {@link HttpTransport}.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type header to use for requests. By default this is {@code
 "application/json-rpc"}.]]>
      </doc>
    </field>
    <field name="accept" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Accept header to use for requests. By default this is {@code
 "application/json-rpc"}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON-RPC 2.0 HTTP transport for RPC requests, including both singleton and
 batched requests.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.rpc2.JsonRpcHttpTransport -->
  <!-- start class com.google.api.client.json.rpc2.JsonRpcRequest -->
  <class name="JsonRpcRequest" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JsonRpcRequest"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="jsonrpc" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String specifying the version of the JSON-RPC protocol. MUST be exactly
 "2.0".]]>
      </doc>
    </field>
    <field name="id" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An identifier established by the Client that MUST contain a String or a
 Number. If it is not included it is assumed to be a notification, and will
 not receive a response.]]>
      </doc>
    </field>
    <field name="method" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A String containing the name of the method to be invoked.]]>
      </doc>
    </field>
    <field name="params" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A Structured value that holds the parameter values to be used during the
 invocation of the method. This member MAY be omitted.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[JSON-RPC 2.0 request object.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.json.rpc2.JsonRpcRequest -->
  <doc>
  <![CDATA[JSON-RPC 2.0 as specified in
<a href="http://groups.google.com/group/json-rpc/web/json-rpc-2-0">JSON-RPC
2.0 Specification</a>
and
<a href="http://groups.google.com/group/json-rpc/web/json-rpc-over-http">JSON-RPC
over HTTP</a>
.

<p>This package depends on the {@link com.google.api.client.json} and {@link
com.google.api.client.util} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.repackaged.com.google.common.base">
  <!-- start class com.google.api.client.repackaged.com.google.common.base.Objects -->
  <class name="Objects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="equal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines whether two possibly-null objects are equal. Returns:

 <ul>
 <li>{@code true} if {@code a} and {@code b} are both null.
 <li>{@code true} if {@code a} and {@code b} are both non-null and they are
     equal according to {@link Object#equals(Object)}.
 <li>{@code false} in all other situations.
 </ul>

 <p>This assumes that any non-null objects passed to this function conform
 to the {@code equals()} contract.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper functions that can operate on any {@code Object}.

 @author Laurence Gonsalves
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.repackaged.com.google.common.base.Objects -->
  <!-- start class com.google.api.client.repackaged.com.google.common.base.Preconditions -->
  <class name="Preconditions" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalArgumentException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkArgument"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving one or more parameters to the
 calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalArgumentException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @throws IllegalStateException if {@code expression} is false]]>
      </doc>
    </method>
    <method name="checkState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expression" type="boolean"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures the truth of an expression involving the state of the calling
 instance, but not involving any parameters to the calling method.

 @param expression a boolean expression
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @throws IllegalStateException if {@code expression} is false
 @throws NullPointerException if the check fails and either {@code
     errorMessageTemplate} or {@code errorMessageArgs} is null (don't let
     this happen)]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessage" type="java.lang.Object"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessage the exception message to use if the check fails; will
     be converted to a string using {@link String#valueOf(Object)}
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkNotNull" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reference" type="T"/>
      <param name="errorMessageTemplate" type="java.lang.String"/>
      <param name="errorMessageArgs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Ensures that an object reference passed as a parameter to the calling
 method is not null.

 @param reference an object reference
 @param errorMessageTemplate a template for the exception message should the
     check fail. The message is formed by replacing each {@code %s}
     placeholder in the template with an argument. These are matched by
     position - the first {@code %s} gets {@code errorMessageArgs[0]}, etc.
     Unmatched arguments will be appended to the formatted message in square
     braces. Unmatched placeholders will be left as-is.
 @param errorMessageArgs the arguments to be substituted into the message
     template. Arguments are converted to strings using
     {@link String#valueOf(Object)}.
 @return the non-null reference that was validated
 @throws NullPointerException if {@code reference} is null]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkElementIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>element</i> in an array,
 list or string of size {@code size}. An element index may range from zero,
 inclusive, to {@code size}, exclusive.

 @param index a user-supplied index identifying an element of an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is not
     less than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="size" type="int"/>
      <param name="desc" type="java.lang.String"/>
      <doc>
      <![CDATA[Ensures that {@code index} specifies a valid <i>position</i> in an array,
 list or string of size {@code size}. A position index may range from zero
 to {@code size}, inclusive.

 @param index a user-supplied index identifying a position in an array, list
     or string
 @param size the size of that array, list or string
 @param desc the text to use to describe this index in an error message
 @return the value of {@code index}
 @throws IndexOutOfBoundsException if {@code index} is negative or is
     greater than {@code size}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <method name="checkPositionIndexes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Ensures that {@code start} and {@code end} specify a valid <i>positions</i>
 in an array, list or string of size {@code size}, and are in order. A
 position index may range from zero to {@code size}, inclusive.

 @param start a user-supplied index identifying a starting position in an
     array, list or string
 @param end a user-supplied index identifying a ending position in an array,
     list or string
 @param size the size of that array, list or string
 @throws IndexOutOfBoundsException if either index is negative or is
     greater than {@code size}, or if {@code end} is less than {@code start}
 @throws IllegalArgumentException if {@code size} is negative]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple static methods to be called at the start of your own methods to verify
 correct arguments and state. This allows constructs such as
 <pre>
     if (count <= 0) {
       throw new IllegalArgumentException("must be positive: " + count);
     }</pre>

 to be replaced with the more compact
 <pre>
     checkArgument(count > 0, "must be positive: %s", count);</pre>

 Note that the sense of the expression is inverted; with {@code Preconditions}
 you declare what you expect to be <i>true</i>, just as you do with an
 <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/assert.html">
 {@code assert}</a> or a JUnit {@code assertTrue} call.

 <p><b>Warning:</b> only the {@code "%s"} specifier is recognized as a
 placeholder in these messages, not the full range of {@link
 String#format(String, Object[])} specifiers.

 <p>Take care not to confuse precondition checking with other similar types
 of checks! Precondition exceptions -- including those provided here, but also
 {@link IndexOutOfBoundsException}, {@link NoSuchElementException}, {@link
 UnsupportedOperationException} and others -- are used to signal that the
 <i>calling method</i> has made an error. This tells the caller that it should
 not have invoked the method when it did, with the arguments it did, or
 perhaps ever. Postcondition or other invariant failures should not throw
 these types of exceptions.

 @author Kevin Bourrillion
 @since 2 (imported from Google Collections Library)]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.repackaged.com.google.common.base.Preconditions -->
  <doc>
  <![CDATA[Copied from
<a href="http://code.google.com/p/guava-libraries">guava-libraries</a>
, but only keeping the stuff we actually need.

<p>Rather than having an explicit dependency on guava-libraries, we
repackage just the few classes we need from guava-libraries to better support
low-space environments like Android. Note that some functionality may be removed
from some of the classes to minimize size, so it is not necessarily an exact
copy.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.util">
  <!-- start class com.google.api.client.util.ArrayMap -->
  <class name="ArrayMap" extends="java.util.AbstractMap&lt;K, V&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="ArrayMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new instance of an array map with initial capacity of zero.
 Equivalent to calling the default constructor, except without the need to
 specify the type parameters. For example: {@code ArrayMap<String, String>
 map = ArrayMap.create();}.]]>
      </doc>
    </method>
    <method name="create" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="initialCapacity" type="int"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given initial capacity. For
 example: {@code ArrayMap<String, String> map = ArrayMap.create(8);}.]]>
      </doc>
    </method>
    <method name="of" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyValuePairs" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns a new instance of an array map of the given key value pairs in
 alternating order. For example: {@code ArrayMap<String, String> map =
 ArrayMap.of("key1", "value1", "key2", "value2", ...);}.
 <p>
 WARNING: there is no compile-time checking of the {@code keyValuePairs}
 parameter to ensure that the keys or values have the correct type, so if
 the wrong type is passed in, any problems will occur at runtime. Also,
 there is no checking that the keys are unique, which the caller must ensure
 is true.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value pairs set.]]>
      </doc>
    </method>
    <method name="getKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the key at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="getValue" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the value at the given index or {@code null} if out of bounds.]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the key/value mapping at the given index, overriding any existing
 key/value mapping.
 <p>
 There is no checking done to ensure that the key does not already exist.
 Therefore, this method is dangerous to call unless the caller can be
 certain the key does not already exist in the map.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="set" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value at the given index, overriding any existing value mapping.

 @return previous value or {@code null} for none
 @throws IndexOutOfBoundsException if index is negative or {@code >=} size]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Adds the key/value mapping at the end of the list. Behaves identically to
 {@code set(size(), key, value)}.

 @throws IndexOutOfBoundsException if index is negative]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Removes the key/value mapping at the given index, or ignored if the index
 is out of bounds.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether there is a mapping for the given key.]]>
      </doc>
    </method>
    <method name="getIndexOfKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns the index of the given key or {@code -1} if there is no such key.]]>
      </doc>
    </method>
    <method name="get" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value set for the given key or {@code null} if there is no such
 mapping or if the mapping value is {@code null}.]]>
      </doc>
    </method>
    <method name="put" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="V"/>
      <doc>
      <![CDATA[Sets the value for the given key, overriding any existing value.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="remove" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the key-value pair of the given key, or ignore if the key cannot be
 found.

 @return previous value or {@code null} for none]]>
      </doc>
    </method>
    <method name="trim"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Trims the internal array storage to minimize memory usage.]]>
      </doc>
    </method>
    <method name="ensureCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="minCapacity" type="int"/>
      <doc>
      <![CDATA[Ensures that the capacity of the internal arrays is at least a given
 capacity.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;K, V&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.ArrayMap&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Memory-efficient map of keys to values with list-style random-access
 semantics.
 <p>
 Conceptually, the keys and values are stored in a simpler array in order to
 minimize memory use and provide for fast access to a key/value at a certain
 index (for example {@link #getKey(int)}). However, traditional mapping
 operations like {@link #get(Object)} and {@link #put(Object, Object)} are
 slower because they need to look up all key/value pairs in the worst case.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ArrayMap -->
  <!-- start class com.google.api.client.util.Base64 -->
  <class name="Base64" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[])} but returns
 a byte array instead of instantiating a String. This is more efficient
 if you're working with I/O streams and have large data sets to encode.


 @param source The data to convert
 @return The Base64-encoded data as a byte[] (of ASCII characters)
 @throws NullPointerException if source array is null
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Similar to {@link #encode(byte[], int, int)} but returns
 a byte array instead of instantiating a String. This is more efficient
 if you're working with I/O streams and have large data sets to encode.


 @param source The data to convert
 @param off Offset in array where conversion should begin
 @param len Length of data to convert
 @return The Base64-encoded data as a String
 @throws NullPointerException if source array is null
 @throws IllegalArgumentException if source array, offset, or length are invalid
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in
 the form of a byte array. <strong>Ignores GUNZIP option, if
 it's set.</strong> This is not generally a recommended method,
 although it is used internally as part of the decoding process.
 Special case: if len = 0, an empty array is returned. Still,
 if you need more speed and reduced memory footprint (and aren't
 gzipping), consider this method.

 @param source The Base64 encoded data
 @return decoded data
 @since 2.3.1]]>
      </doc>
    </method>
    <method name="decode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Low-level access to decoding ASCII characters in
 the form of a byte array. <strong>Ignores GUNZIP option, if
 it's set.</strong> This is not generally a recommended method,
 although it is used internally as part of the decoding process.
 Special case: if len = 0, an empty array is returned. Still,
 if you need more speed and reduced memory footprint (and aren't
 gzipping), consider this method.

 @param source The Base64 encoded data
 @param off    The offset of where to begin decoding
 @param len    The length of characters to decode
 @return decoded data
 @throws java.io.IOException If bogus characters exist in source data
 @since 1.3]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encodes and decodes to and from Base64 notation.
 <p>
 Homepage: <a href="http://iharder.net/base64">http://iharder.net/base64</a>.
 </p>
 
 @author Robert Harder (rob@iharder.net)
 @since 1.0]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Base64 -->
  <!-- start class com.google.api.client.util.ClassInfo -->
  <class name="ClassInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the class information for the given class.
 
 @param clazz class or {@code null} for {@code null} result
 @return class information or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <method name="getFieldInfo" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the information for the given data key name.
 
 @param keyName data key name or {@code null} for {@code null} result
 @return field information or {@code null} for none or for {@code null}
         input]]>
      </doc>
    </method>
    <method name="getField" return="java.lang.reflect.Field"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the field for the given data key name.
 
 @param keyName data key name or {@code null} for {@code null} result
 @return field or {@code null} for none or for {@code null} input]]>
      </doc>
    </method>
    <method name="getKeyCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of data key name/value pairs associated with this data
 class.]]>
      </doc>
    </method>
    <method name="getKeyNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the data key names associated with this data class.]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a new instance of the given class using reflection.]]>
      </doc>
    </method>
    <method name="newCollectionInstance" return="java.util.Collection&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collectionClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of the given collection class.
 <p>
 If a concrete collection class in the The class of the returned collection
 instance depends on the input collection class as follows (first that
 matches):
 <ul>
 <li>{@code null} or {@link ArrayList} is an instance of the collection
 class: returns an {@link ArrayList}</li>
 <li>Concrete subclass of {@link Collection}: returns an instance of that
 collection class</li>
 <li>{@link HashSet} is an instance of the collection class: returns a
 {@link HashSet}</li>
 <li>{@link TreeSet} is an instance of the collection class: returns a
 {@link TreeSet}</li>
 </ul>
 
 @param collectionClass collection class or {@code null} for
        {@link ArrayList}.
 @return new collection instance]]>
      </doc>
    </method>
    <method name="newMapInstance" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new instance of the given map class.]]>
      </doc>
    </method>
    <method name="getCollectionParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the type parameter for the given field assuming it is of type
 collection.]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the type parameter for the given field assuming it is of type map.]]>
      </doc>
    </method>
    <method name="getMapValueParameter" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="genericType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns the type parameter for the given genericType assuming it is of type
 map.]]>
      </doc>
    </method>
    <field name="clazz" type="java.lang.Class&lt;?&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses class information to determine data key name/value pairs associated
 with the class.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ClassInfo -->
  <!-- start class com.google.api.client.util.DataUtil -->
  <class name="DataUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="mapOf" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the map to use for the given key/value data.
 
 @param data any key value data, represented by an object or a map, or
        {@code null}
 @return if {@code data} is a map returns {@code data}; else if {@code data}
         is {@code null}, returns an empty map; else returns
         {@link ReflectionMap} on the data object]]>
      </doc>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="T"/>
      <doc>
      <![CDATA[Returns a deep clone of the given key/value data, such that the result is a
 completely independent copy.
 <p>
 Note that final fields cannot be changed and therefore their value won't be
 copied.
 
 @param data key/value data object or map to clone or {@code null} for a
        {@code null} return value
 @return deep clone or {@code null} for {@code null} input]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for working with key/value data.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.DataUtil -->
  <!-- start class com.google.api.client.util.DateTime -->
  <class name="DateTime" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DateTime" type="java.util.Date, java.util.TimeZone"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="java.util.Date"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DateTime" type="boolean, long, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toStringRfc3339" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Formats the value as an RFC 3339 date/time string.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="parseRfc3339" return="com.google.api.client.util.DateTime"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="NumberFormatException" type="java.lang.NumberFormatException"/>
      <doc>
      <![CDATA[Parses an RFC 3339 date/time value.]]>
      </doc>
    </method>
    <field name="value" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Date/time value expressed as the number of ms since the Unix epoch.
 
 If the time zone is specified, this value is normalized to UTC, so to
 format this date/time value, the time zone shift has to be applied.]]>
      </doc>
    </field>
    <field name="dateOnly" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Specifies whether this is a date-only value.]]>
      </doc>
    </field>
    <field name="tzShift" type="java.lang.Integer"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Time zone shift from UTC in minutes. If {@code null}, no time zone is set,
 and the time is always interpreted as local time.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Immutable representation of a date with an optional time and an optional time
 zone based on RFC 3339.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.DateTime -->
  <!-- start class com.google.api.client.util.FieldInfo -->
  <class name="FieldInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.api.client.util.FieldInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the field information for the given field.
 
 @param field field or {@code null} for {@code null} result
 @return field information or {@code null} if the field has no {@link Key}
         annotation or for {@code null} input]]>
      </doc>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the field in the given object instance using
 reflection.]]>
      </doc>
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the field in the given object instance using
 reflection.
 <p>
 If the field is final, it checks that value being set is identical to the
 existing value.]]>
      </doc>
    </method>
    <method name="getClassInfo" return="com.google.api.client.util.ClassInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class information of the field's declaring class.]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns whether the given field class is one of the supported primitive
 types like number and date/time.]]>
      </doc>
    </method>
    <method name="isPrimitive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns whether to given value is {@code null} or its class is primitive as
 defined by {@link #isPrimitive(Class)}.]]>
      </doc>
    </method>
    <method name="getFieldValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value of the given field in the given object instance using
 reflection.]]>
      </doc>
    </method>
    <method name="setFieldValue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets to the given value of the given field in the given object instance
 using reflection.
 <p>
 If the field is final, it checks that value being set is identical to the
 existing value.]]>
      </doc>
    </method>
    <method name="parsePrimitiveValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="primitiveClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="stringValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parses the given string value based on the given primitive class.
 <p>
 Types are parsed as follows:
 <ul>
 <li>{@code null} or {@link String}: no parsing</li>
 <li>{@code char} or {@link Character}: {@link String#charAt(int)
 String.charAt}(0) (requires length to be exactly 1)</li>
 <li>{@code boolean} or {@link Boolean}: {@link Boolean#valueOf(String)}</li>
 <li>{@code byte} or {@link Byte}: {@link Byte#valueOf(String)}</li>
 <li>{@code short} or {@link Short}: {@link Short#valueOf(String)}</li>
 <li>{@code int} or {@link Integer}: {@link Integer#valueOf(String)}</li>
 <li>{@code long} or {@link Long}: {@link Long#valueOf(String)}</li>
 <li>{@code float} or {@link Float}: {@link Float#valueOf(String)}</li>
 <li>{@code double} or {@link Double}: {@link Double#valueOf(String)}</li>
 <li>{@link BigInteger}: {@link BigInteger#BigInteger(String)
 BigInteger(String)}</li>
 <li>{@link BigDecimal}: {@link BigDecimal#BigDecimal(String)
 BigDecimal(String)}</li>
 <li>{@link DateTime}: {@link DateTime#parseRfc3339(String)}</li>
 </ul>
 Note that this may not be the right behavior for some use cases.
 
 @param primitiveClass primitive class (see {@link #isPrimitive(Class)} or
        {@code null} to parse as a string
 @param stringValue string value to parse or {@code null} for {@code null}
        result
 @return parsed object or {@code null} for {@code null} input
 @throws IllegalArgumentException if the given class is not a primitive
         class as defined by {@link #isPrimitive(Class)}]]>
      </doc>
    </method>
    <field name="isFinal" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the field is final.]]>
      </doc>
    </field>
    <field name="isPrimitive" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the field class is "primitive" as defined by
 {@link FieldInfo#isPrimitive(Class)}.]]>
      </doc>
    </field>
    <field name="type" type="java.lang.Class&lt;?&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Field class.]]>
      </doc>
    </field>
    <field name="field" type="java.lang.reflect.Field"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Field.]]>
      </doc>
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Data key name associated with the field. This string is interned.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Parses field information to determine data key name/value pair associated
 with the field.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.FieldInfo -->
  <!-- start class com.google.api.client.util.GenericData -->
  <class name="GenericData" extends="java.util.AbstractMap&lt;java.lang.String, java.lang.Object&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericData"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the given field value (may be {@code null}) for the given field name.
 Any existing value for the field will be overwritten. It may be more
 slightly more efficient than {@link #put(String, Object)} because it avoids
 accessing the field's original value.]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="java.util.Map&lt;? extends java.lang.String, ?&gt;"/>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clone" return="com.google.api.client.util.GenericData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="unknownFields" type="com.google.api.client.util.ArrayMap&lt;java.lang.String, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of unknown fields.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic data that stores all unknown data key name/value pairs.
 <p>
 Subclasses can declare fields for known data keys using the {@link Key}
 annotation. Each field can be of any visibility (private, package private,
 protected, or public) and must not be static. {@code null} unknown data key
 names are not allowed, but {@code null} data values are allowed.
 <p>
 Iteration order of the data keys is based on the sorted (ascending) key names
 of the declared fields, followed by the iteration order of all of the unknown
 data key name/value pairs.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.GenericData -->
  <!-- start class com.google.api.client.util.Key -->
  <class name="Key"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Use this annotation to specify that a field is a data key, optionally
 providing the data key name to use.
 <p>
 If the data key name is not specifies, the default data key name is the
 field's name. For example:
 
 <code><pre>public class A {
 
   // uses data key name of "dataKeyNameMatchesFieldName" 
   &#64;Key
   public String dataKeyNameMatchesFieldName;
   
   // uses data key name of "some_other_name"
   &#64;Key("some_other_name") 
   private String dataKeyNameIsOverriden;
   
   // not a data key
   private String notADataKey; 
 }</pre></code>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Key -->
  <!-- start class com.google.api.client.util.ReflectionMap -->
  <class name="ReflectionMap" extends="java.util.AbstractMap&lt;java.lang.String, java.lang.Object&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReflectionMap" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="entrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Map that uses {@link ClassInfo} to parse the key/value pairs into a map.
 <p>
 Iteration order of the keys is based on the sorted (ascending) key names.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.ReflectionMap -->
  <!-- start class com.google.api.client.util.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="LINE_SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Line separator to use for this OS, i.e. {@code "\n"} or {@code "\r\n"}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Utilities for strings.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.util.Strings -->
  <doc>
  <![CDATA[General utilities used throughout this library.

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.xml">
  <!-- start class com.google.api.client.xml.AbstractXmlHttpContent -->
  <class name="AbstractXmlHttpContent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpContent"/>
    <constructor name="AbstractXmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getEncoding" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code null}, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default implementation returns {@code -1}, but subclasses may override.]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link XmlHttpParser#CONTENT_TYPE}, though
 subclasses may define a different default value.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Abstract serializer for XML HTTP content based on the data key/value mapping
 object for an item.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.AbstractXmlHttpContent -->
  <!-- start class com.google.api.client.xml.DefaultXmlParserFactory -->
  <class name="DefaultXmlParserFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.xml.XmlParserFactory"/>
    <method name="getInstance" return="com.google.api.client.xml.DefaultXmlParserFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Returns the only instance of the default XML parser factory.]]>
      </doc>
    </method>
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <doc>
    <![CDATA[Default XML parser factory that uses the default specified in
 {@link XmlPullParserFactory}.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.DefaultXmlParserFactory -->
  <!-- start class com.google.api.client.xml.GenericXml -->
  <class name="GenericXml" extends="com.google.api.client.util.GenericData"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Cloneable"/>
    <constructor name="GenericXml"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clone" return="com.google.api.client.xml.GenericXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional XML element local name prefixed by its namespace alias -- for
 example {@code "atom:entry"} -- or {@code null} if not set.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Optional namespace dictionary or {@code null} if not set.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Generic XML data that stores all unknown key name/value pairs.
 <p>
 Each data key name maps into the name of the XPath expression value for the
 XML element, attribute, or text content (using {@code "text()"}). Subclasses
 can declare fields for known XML content using the {@link Key} annotation.
 Each field can be of any visibility (private, package private, protected, or
 public) and must not be static. {@code null} unknown data key names are not
 allowed, but {@code null} data values are allowed.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.GenericXml -->
  <!-- start class com.google.api.client.xml.Xml -->
  <class name="Xml" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a new XML serializer.

 @throws IllegalArgumentException if encountered an
         {@link XmlPullParserException}]]>
      </doc>
    </method>
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Returns a new XML pull parser.]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value
 pairs.
 <p>
 It will make up something for the element name and XML namespaces. If those
 are known, it is better to use
 {@link XmlNamespaceDictionary#toStringOf(String, Object)}.

 @param element element data object of key/value pairs ({@link GenericXml},
        {@link Map}, or any object with public fields)]]>
      </doc>
    </method>
    <method name="parseElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parser" type="XmlPullParser"/>
      <param name="destination" type="java.lang.Object"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="customizeParser" type="com.google.api.client.xml.Xml.CustomizeParser"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parses an XML elment using the given XML pull parser into the given
 destination object.
 <p>
 Requires the the current event be {@link XmlPullParser#START_TAG} (skipping
 any initial {@link XmlPullParser#START_DOCUMENT}) of the element being
 parsed. At normal parsing completion, the current event will either be
 {@link XmlPullParser#END_TAG} of the element being parsed, or the
 {@link XmlPullParser#START_TAG} of the requested {@code atom:entry}.

 @param parser XML pull parser
 @param destination optional destination object to parser into or {@code
        null} to ignore XML content
 @param namespaceDictionary XML namespace dictionary to store unknown
        namespaces
 @param customizeParser optional parser customizer or {@code null} for none]]>
      </doc>
    </method>
    <field name="parserFactory" type="com.google.api.client.xml.XmlParserFactory"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML Parser factory.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[XML utilities.

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml -->
  <!-- start class com.google.api.client.xml.Xml.CustomizeParser -->
  <class name="Xml.CustomizeParser" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Xml.CustomizeParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stopBeforeStartTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the start tag of an XML
 element before it has been processed. Only called if the element is
 actually being processed. By default, returns {@code false}, but
 subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <method name="stopAfterEndTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <param name="localName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether to stop parsing when reaching the end tag of an XML
 element after it has been processed. Only called if the element is
 actually being processed. By default, returns {@code false}, but
 subclasses may override.

 @param namespace XML element's namespace URI
 @param localName XML element's local name]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Customizes the behavior of XML parsing. Subclasses may override any methods
 they need to customize behavior.]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.Xml.CustomizeParser -->
  <!-- start class com.google.api.client.xml.XmlHttpContent -->
  <class name="XmlHttpContent" extends="com.google.api.client.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlHttpContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="elementName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML element local name, optionally prefixed by its namespace alias, for
 example {@code "atom:entry"}.]]>
      </doc>
    </field>
    <field name="data" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes XML HTTP content based on the data key/value mapping object for an
 item.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request,
     XmlNamespaceDictionary namespaceDictionary, String elementName,
     Object data) {
   XmlHttpContent content = new XmlHttpContent();
   content.namespaceDictionary = namespaceDictionary;
   content.elementName = elementName;
   content.data = data;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.XmlHttpContent -->
  <!-- start class com.google.api.client.xml.XmlHttpParser -->
  <class name="XmlHttpParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.api.client.http.HttpParser"/>
    <constructor name="XmlHttpParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parse" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="dataClass" type="java.lang.Class&lt;T&gt;"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Default implementation parses the content of the response into the data
 class of key/value pairs, but subclasses may override.]]>
      </doc>
    </method>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@code "application/xml"} content type.]]>
      </doc>
    </field>
    <field name="contentType" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Content type. Default value is {@link #CONTENT_TYPE}.]]>
      </doc>
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[XML namespace dictionary.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[XML HTTP parser into an data class of key/value pairs.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setParser(HttpTransport transport) {
   XmlHttpParser parser = new XmlHttpParser();
   parser.namespaceDictionary = NAMESPACE_DICTIONARY;
   transport.addParser(parser);
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.XmlHttpParser -->
  <!-- start class com.google.api.client.xml.XmlNamespaceDictionary -->
  <class name="XmlNamespaceDictionary" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="XmlNamespaceDictionary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a known namespace of the given alias and URI.

 @param alias alias
 @param uri namespace URI]]>
      </doc>
    </method>
    <method name="toStringOf" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value
 pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any
        object with public fields)
 @param elementName optional XML element local name prefixed by its
        namespace alias -- for example {@code "atom:entry"} -- or {@code
        null} to make up something]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementNamespaceUri" type="java.lang.String"/>
      <param name="elementLocalName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value
 pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any
        object with public fields)
 @param elementNamespaceUri XML namespace URI or {@code null} for no
        namespace
 @param elementLocalName XML local name
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <param name="elementName" type="java.lang.String"/>
      <param name="element" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Shows a debug string representation of an element data object of key/value
 pairs.

 @param element element data object ({@link GenericXml}, {@link Map}, or any
        object with public fields)
 @param elementName XML element local name prefixed by its namespace alias
 @throws IOException I/O exception]]>
      </doc>
    </method>
    <field name="namespaceAliasToUriMap" type="java.util.HashMap&lt;java.lang.String, java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map from XML namespace alias (or {@code ""} for the default namespace) to
 XML namespace URI.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[XML namespace dictionary that maps namespace aliases to URI.
 <p>
 Sample usage:

 <pre><code>static final XmlNamespaceDictionary NAMESPACE_DICTIONARY = new * XmlNamespaceDictionary(); * static { * Map<String, String> map = NAMESPACE_DICTIONARY.namespaceAliasToUriMap; * map.put("", "http://www.w3.org/2005/Atom"); * map.put("activity", "http://activitystrea.ms/spec/1.0/"); * map.put("georss", "http://www.georss.org/georss"); * map.put("media", "http://search.yahoo.com/mrss/"); * map.put("thr", "http://purl.org/syndication/thread/1.0"); * }</code> * </pre>

 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.XmlNamespaceDictionary -->
  <!-- start interface com.google.api.client.xml.XmlParserFactory -->
  <interface name="XmlParserFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createParser" return="XmlPullParser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Creates a new XML pull parser.
 
 @throws XmlPullParserException if parser could not be created]]>
      </doc>
    </method>
    <method name="createSerializer" return="XmlSerializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Creates a new XML serializer.
 
 @throws XmlPullParserException if serializer could not be created]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory for creating new XML pull parsers and XML serializers.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </interface>
  <!-- end interface com.google.api.client.xml.XmlParserFactory -->
  <doc>
  <![CDATA[XML.
<p>This package depends on the {@link com.google.api.client.util}, {@link
com.google.api.client.http}, and {@code org.xmlpull.v1} packages.</p>

<p>This package depends on the {@link com.google.api.client.util} and {@link
org.codehaus.jackson} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>
<package name="com.google.api.client.xml.atom">
  <!-- start class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <class name="AbstractAtomFeedParser" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseFeed" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the feed and return a new parsed instance of the feed type. This
 method can be skipped if all you want are the items.
 
 @throws XmlPullParserException]]>
      </doc>
    </method>
    <method name="parseNextEntry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <doc>
      <![CDATA[Parse the next item in the feed and return a new parsed instanceof of the
 item type. If there is no item to parse, it will return {@code null} and
 automatically close the parser (in which case there is no need to call
 {@link #close()}.
 
 @throws XmlPullParserException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes the underlying parser.]]>
      </doc>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <field name="parser" type="XmlPullParser"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="inputStream" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="feedClass" type="java.lang.Class&lt;T&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Abstract base class for an Atom feed parser when the feed type is known in
 advance.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AbstractAtomFeedParser -->
  <!-- start class com.google.api.client.xml.atom.Atom -->
  <class name="Atom" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="checkContentType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contentType" type="java.lang.String"/>
    </method>
    <field name="ATOM_NAMESPACE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONTENT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.Atom -->
  <!-- start class com.google.api.client.xml.atom.AtomContent -->
  <class name="AtomContent" extends="com.google.api.client.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="entry" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom entry.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object
 for an Atom entry.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request,
     XmlNamespaceDictionary namespaceDictionary, Object entry) {
   AtomContent content = new AtomContent();
   content.namespaceDictionary = namespaceDictionary;
   content.entry = entry;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomContent -->
  <!-- start class com.google.api.client.xml.atom.AtomFeedContent -->
  <class name="AtomFeedContent" extends="com.google.api.client.xml.AbstractXmlHttpContent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomFeedContent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="serializer" type="XmlSerializer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="feed" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key/value pair data for the Atom feed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serializes Atom XML HTTP content based on the data key/value mapping object
 for an Atom feed.
 <p>
 Default value for {@link #contentType} is {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setContent(HttpRequest request,
     XmlNamespaceDictionary namespaceDictionary, Object feed) {
   AtomFeedContent content = new AtomFeedContent();
   content.namespaceDictionary = namespaceDictionary;
   content.feed = feed;
   request.content = content;
 }
 </code>
 </pre>
 
 @since 1.1
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomFeedContent -->
  <!-- start class com.google.api.client.xml.atom.AtomFeedParser -->
  <class name="AtomFeedParser" extends="com.google.api.client.xml.atom.AbstractAtomFeedParser&lt;T&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomFeedParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseNextEntry" return="I"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="parseEntryInternal" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
    </method>
    <method name="create" return="com.google.api.client.xml.atom.AtomFeedParser&lt;T, I&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="com.google.api.client.http.HttpResponse"/>
      <param name="namespaceDictionary" type="com.google.api.client.xml.XmlNamespaceDictionary"/>
      <param name="feedClass" type="java.lang.Class&lt;T&gt;"/>
      <param name="entryClass" type="java.lang.Class&lt;I&gt;"/>
      <exception name="XmlPullParserException" type="XmlPullParserException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="entryClass" type="java.lang.Class&lt;I&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Atom feed parser when the item class is known in advance.
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomFeedParser -->
  <!-- start class com.google.api.client.xml.atom.AtomParser -->
  <class name="AtomParser" extends="com.google.api.client.xml.XmlHttpParser"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomParser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Atom XML HTTP parser into an data class of key/value pairs.
 <p>
 It overrides the {@link #contentType} to {@link Atom#CONTENT_TYPE}.
 <p>
 Sample usage:
 
 <pre>
 <code>
 static void setParser(HttpTransport transport) {
   AtomParser parser = new AtomParser();
   parser.namespaceDictionary = NAMESPACE_DICTIONARY;
   transport.addParser(parser);
 }
 </code>
 </pre>
 
 @since 1.0
 @author Yaniv Inbar]]>
    </doc>
  </class>
  <!-- end class com.google.api.client.xml.atom.AtomParser -->
  <doc>
  <![CDATA[Atom XML.

<p>This package depends on the {@link com.google.api.client.http}, {@link
com.google.api.client.util}, {@link com.google.api.client.xml}, and {@code
org.xmlpull.v1} packages.</p>

<p><b>Warning: this package is experimental, and its content may be
changed in incompatible ways or possibly entirely removed in a future version of
the library</b></p>

@since 1.0]]>
  </doc>
</package>

</api>
